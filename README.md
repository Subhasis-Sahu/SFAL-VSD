# SFAL_VSD
<details>

<summary>Day 0 - Tools Installation</summary>


    Commands to install Yosys in Linux:
    $ git clone https://github.com/YosysHQ/yosys.git
    $ cd yosys
    $ sudo apt install make (If make is not installed) 
    $ sudo apt-get install build-essential clang bison flex \
        libreadline-dev gawk tcl-dev libffi-dev git \
        graphviz xdot pkg-config python3 libboost-system-dev \
        libboost-python-dev libboost-filesystem-dev zlib1g-dev
    $ make config-gcc
    $ make 
    $ sudo make install

  Type yosys in terminal to start yosys tool:
  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/8ab7f131-3db4-4966-b49f-ae961000daea)

    Commands to install iverilog in Linux:
    sudo apt-get install iverilog

  iverilog tool installation:
  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c69254de-1f38-4abc-a315-7c0c28b2596f)

    Commands to install gtkwave in Linux:
    sudo apt update
    sudo apt install gtkwave

  Open gtkwave tool by typing gtkwave in terminal:
  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/963ed335-5e2a-48d7-9319-349895f5fe91)

</details>

<details>

<summary>Day 1 - Introduction to Verilog RTL Design and Synthesis</summary>


      Design: Design is the actual verilog code or set of verilog codes which has the intended functionality to meet the required specifications.
      Simulator: It is the tool which is used for checking if the given design meet its intended functional specifications.
      Testbench: Testbench is the setup,which is used to apply stimulus(test_vectors)  the design to check its functionality.

  Basic Structure of a Testbench:
  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/15fa9130-e1b6-48ad-b7b0-19214a7d8823)

    iverilog Simulator flow:
    Inputs to iverilog: Design files and testbench files
    Outputs of iverilog: .vcd(value change dump) file (Value change dump (VCD) (also known less commonly as "variable change dump") is an ASCII-based format for dumpfiles generated by EDA logic simulation tools)
    This .vcd file can be used as input in gtkwave tool to view waveforms of the signals of the design and verify the correctness of their transitions,in accordance to the stimulus provided by our testbench.
          
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/60d3bfb0-20e6-412a-9c2a-2f054f20d921)

    good_mux.v design:
    
    module good_mux (input i0 , input i1 , input sel , output reg y);
    always @ (*)
    begin
    	if(sel)
    		y <= i1;
    	else 
    		y <= i0;
    end
    endmodule
    
    tb_good_mux.v testbench:
    
        `timescale 1ns / 1ps
        module tb_good_mux;
    	// Inputs
    	reg i0,i1,sel;
    	// Outputs
    	wire y;
    
            // Instantiate the Unit Under Test (UUT)
    	good_mux uut (
    		.sel(sel),
    		.i0(i0),
    		.i1(i1),
    		.y(y)
    	);
    
    	initial begin
    	$dumpfile("tb_good_mux.vcd");
    	$dumpvars(0,tb_good_mux);
    	// Initialize Inputs
    	sel = 0;
    	i0 = 0;
    	i1 = 0;
    	#300 $finish;
    	end
    
        always #75 sel = ~sel;
        always #10 i0 = ~i0;
        always #55 i1 = ~i1;
        endmodule
        
    Running iverilog & gtkwave:
    git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop #clone design and testbench and synthesis collaterals required for lab.
    cd sky130RTLDesignAndSynthesisWorkshop/verilog_files #change directory to the destination folder
    iverilog good_mux.v tb_good_mux.v #runs iverilog simulator for design good_mux and testbench tb_good_mux, craetes a "a.out" file in present working directory.
    ./a.out #executes a.out file to dump the tb_good_mux.vcd file
    gtkwave tb_good_mux.vcd #open .vcd file in gtkwave to observe waveforms

Screenshot of commands run:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/b07321eb-7f8d-47f6-8cd1-b910ffac05e3)

gtkwave screenshot:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/ed44c73e-59b9-4556-bb5c-77f7a4d82bea)

Logic Synthesis:
    
    Synthesis is a phase in ASIC design flow. In this phase the hardware description (RTL) is converted to a gate level netlist. This process is performed by a synthesis tool that takes a standard cell library, 
    constraints and the RTL code and produces a gate-level netlist. 
    Synthesis tools run different implementations to provide best gate level netlist that meets the constraints. It takes into account power, speed, size and therefore the results can vary much from each other.      To verify whether the synthesis tool has correctly generated the gate-level netlist,a verification should be done.
    For this lab,we are using Yosys tool as the Synthesis tool.

    
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/1101ed1a-e7bc-40ff-8ac8-1b890e52a7a7)

For the verification of generated netlist,same testbench can be used as primary inputs and outputs are same in both RTL as well as netlist.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/38df0737-ec31-467f-9df9-e15e7589f8d4)

What is .lib?

    In VLSI (Very Large Scale Integration) design, a liberty file, also known as a .lib file, is a standard format file used to represent the timing and power characteristics of digital logic cells. Liberty          files contain information about cell timing, power consumption, input-output capacitances, and other parameters necessary for performing timing analysis and power estimation during the physical design 
    process.
    
    These files are essential for tools like synthesis, place and route, and static timing analysis (STA) to accurately model and optimize the behavior of the designed integrated circuits. Liberty files are 
    usually provided by semiconductor foundries for their standard cell libraries, and designers can also create custom liberty files for their specific designs or libraries.
    
    Liberty files typically contain information such as cell timing arcs, which describe the input-output delay behavior of cells under different input conditions (e.g., rise and fall delays), as well as power- 
    related information such as leakage power and dynamic power consumption.
    
    Overall, liberty files play a crucial role in the implementation and optimization of digital designs in VLSI, ensuring that the final integrated circuits meet performance and power requirements.

    Different flavor of standard cells with respect to threshold voltage,width of transistors etc. are provided to synthesis and implementation tools to meet our performance expectations without timing (setup &      hold) violations.The flavor of cells to be used are controlled by the "Design Constraints or SDC Constraints" provided by the designer.

    Faster cells have wider transistors->less delay -> may cause possible hold violation->comes at cost of area and power.
    Slower cells have narrow transistors->more delay -> may cause possible setup violation

Illustration of Synthesis with specific library components with an example:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/7937d273-f7a1-4896-9c63-4aeca1a51588)

Synthesis of good_mux.v:

    Commands to used in yosys tool:
    read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib # reads target library to be used in synthesis
    read_verilog good_mux.v # read design RTL file
    synth -top good_mux # specify top module of design to be synthesized
    abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib # uses target library std.cells to synthesize the design which has been read

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/bb797dda-e672-4ef7-a1ec-dab9d61a3756)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f6ec3bff-3cad-41fd-a78e-772963e465c6)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/5bdfabd5-5451-4c07-b5bb-2e2722c499f0)

Synthesized netlist screenshot:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a98b3254-ac42-45df-acdd-d5983b542046)

</details>

<details>

<summary>Day 2 - Timing libs, hierarchical vs flat synthesis and efficient flop coding styles</summary>

Understanding Timing Libs:

    Logic Library is .lib file and is also called as Liberty Timing File.
    The parameters related to logical views like area, pin direction, max transition, rise and fall capacitances, fanout load are mentioned in this library file.
    Timing information like cell delay, output transition time for all cells,Setup and hold times for all the flops are part of timing libs.
    Functionality information of Standard cells, IO’s and Macros are part of this library.
    Power information like leakage power, internal power are present in .lib.
    A  .lib(.db)  corresponds  to  a  single  corner  Process  Voltage Temperature (PVT).

.lib screenshot:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/1d2dd651-0339-42eb-bf32-13320925cb15)

Leakage power Info:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/feb261fc-c64f-4936-a079-bba15eef28c9)

Power and Ground pin Info:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/936e0177-f3f1-42ef-86f0-7ce3137fd963)

Timing(Cell rise/fall delay etc.) in lookup table format:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/32550f38-daea-4b3e-9e37-6a9b82e9c67b)

Area comparison of 2-input AND gate of different drive strength/width (we can see higher width cell,has more area):
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/7131b474-29fb-4875-8deb-3fe7810d2804)

Hierarchical vs Flat Synthesis:

    A Hierarchical Design contains of multiple sub-modules,instantiated in the 'top' module.
    Hierachical design approach is taken for large designs, to gain the advantage of divide and conquer approach.
    This leads to better utilization of tool resources for proper optimzation of smaller designs,as a larger design is difficult for a tool to optimize efficiently.
    It helps in better utilization of compute resources utilized during design process,and also leads to faster runtime and debugging operations.

    A flat design approach is chosen when the design is sufficiently small enough for the tool to optimize efficiently in a reasonable amount of time.
    For small and simple ASICs flat approach is preferable while hierarchical approach is preferable for larger,complex ASICs.

Here,we can see the u1 and u2 instances of sub_module1 and sub_module2 respectively are present in RTL and in netlist representation as well(Hierarchy is preserved):
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/99c5681b-bbbd-4409-96a0-6e961095cdb2)

    Sub-modules can be synthesized separately by using the command: synth -top <sub_module_name>

sub_module2 synthesis result:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/144a9525-c34b-4071-9947-ac92e3c3b1bf)

**flatten** command can be used to flatten the design to the top level hierarchy,i.e,hierarchy is removed.

multiple_modules netlist after flattening:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/465ace2e-95ec-49bc-a901-f1a1a832df17)

Why Flip-Flops are used?

Glitches: Glitches are unwanted, temporary spikes or pulses that can occur in digital circuits due to propagation delays in combinational logic.
They arise when multiple paths in a combinational circuit converge on a single node, and the signals along those paths have different propagation delays.

So,Flip-Flops can be used to restrict glitch propagation as:
* Flip-flops are edge triggered circuits,so the output changes on edge of the clock signal,so even if input of flops are glitchy,output remains stable.
* Combinational circuits driven by the flops,will receive stable inputs,hence their glitches will eventually settle down.
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/65789631-376f-4406-9c21-6b8f52663acf)

The value of the flop must be in a known state all the time,for this signals like reset or set are used to control the initial state . set and reset can be synchronous or asynchronous.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/940787d4-3a4e-470b-b7ab-fa2e112b57b5)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/525ee801-6999-4df2-aee8-575b475b250f)

RTL code for different styles of DFFs:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/ad445ebe-7625-4fe1-8a99-cd1f250be2d9)

HDL Simulation of DFF with asynchronous reset.Here,we can observe as soon as async_reset is asserted,DFF output q is reset to '0' logic state:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/cc665588-f9b6-4fc1-aeae-2f145fd2ba68)

dff_asyncres_syncres waveform:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a74513c9-23a3-40d9-ae0c-d51d143426f2)

To Synthesize DFFs,following commands are used in yosys tool:

    read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
    read_verilog dff_asyncres.v
    synth -top dff_asyncres
    dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
    abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
    show

Synthesis without dfflibmap command(DFF inferred in the form of yosys internal generic cells):
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c571db4d-7823-47e1-8406-3a979123136e)

Synthesis with dfflibmap command.Here,we can see the synthesis tool has now correctly mapped the design to the proper dff standard cell present as part of the library.
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9f6d09ea-cf5f-4a50-bbf1-cdbcabf1cd7d)

Note:

    abc -liberty <.lib file path> : This command is used for for technology mapping of yosys’s internal gate library to a target architecture.
    synth -top <module_name> : This command runs the yosys synthesis script on the mentioned module name of our design
    dfflibmap -liberty <.lib file path> : This command maps internal flipflop cells to the flipflop cells in the technology library specified in the given liberty file.

</details>

<details>

<summary>Day 3 - Combinational and sequential optmizations</summary>


Combinational Optimizations:

Synthesis of multiply-by-9:

* y[3:0]=2*a[2:0] -> realized by appending 1'b0 to a[2:0]
* y=9*a can be considered as y=8*a + a -> append 3'b0 to a and then add a to get the value of y -> y = a000 + a -> y={a,a}
* All of the above can be achieved just by wiring.

As we can see in below screenshot,no cell is getting mapped to the design and design is implemented by just using wires:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/2eeefb16-ce31-4785-bb2e-1a90a455589c)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/ab980102-ce88-4f03-be9a-c01e47889ce8)

Constant Propagation:

* Constant propagation in VLSI design refers to the optimization technique used by synthesis tools to minimize hardware implementation by replacing variables with constant values throughout the hardware design.
* This process involves analyzing the flow of constants through the design and replacing variables with known constant values, which can enhance the efficiency of the hardware implementation. 
* Constant propagation is a crucial aspect of optimizing hardware designs to improve performance and reduce unnecessary operations.

For example,in the below logic diagram the constant value of logic '0' at input A leads to the inference of an inverter after logic optimization has occurred:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/69d40684-c2ed-4bca-86ab-7cdfca47c172)

So,in the above example,due to constant propagation,the transistor count is reduced from 6 to 2.

Boolean Logic Optimization:

assign y=a?(b?c:(c?a:0)):(!c)
y=a'c'+a[bc+b'ac]=a'c'+abc+ab'c = a'c'+ac[b+b'] =a'c'+ac= a xor c

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/1b7801c7-c8b7-4322-a17e-3aeeb8fcf9d3)

    opt_clean -purge 
    This pass identifies wires and cells that are unused and removes them. Other passes often remove cells but leave the wires in the design or reconnect the wires but leave the old cells in the design. This    
    pass can be used to clean up after the passes that do the actual work.
    This pass only operates on completely selected modules without processes.
    -purge - also remove internal nets if they have a public name

opt_check.v synthesis:
Here,we can see the mux logic through constant propagation is optimized to AND logic implementation:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3f22e296-ed92-482f-ad0f-449115fa0ffc)

Same outcome can be observed in opt_check2.v synthesis:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/afe8f07b-2dc0-42fc-9339-5c5cf2417940)

For synthesis of opt_check3,const propagation and boolean logic optimaztion leads to AND logic implementation instead of mux implementation:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f12a3d16-2103-488e-a244-073fa4dfed40)

Synthesis of multiple_module_opt.v:
Here,we can see all unused submodules are not part of final netlist implementation,after optimization passes:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/edd9e65a-7334-4210-b133-5d91b8708d8c)

Sequential Logic Optimization:
Different types of Sequential Logic optimization are:

* Sequential Constant Propagation
* Sequential Logic Cloning (When floorplan aware synthesis is performed)
* State optimization
* Retiming

Sequential Constant Propagation:
In the below example,the DFF with grounded D input and async reset,will have output Y=1,due to which no DFF is inferred after optimization.
In the DFF with grounded D input and async set,the same condition cannot be applied because the value of Q is not a constant,and can be changed by asserting async set,here a DFF will be inferred after synthesis.
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3dfe68cf-b6be-4154-8927-5d0465332c44)

Retiming:
Retiming is a technique used to optimize sequential circuits by repositioning the registers (flip-flops) in the circuit without changing the combinational logic.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/96bc946c-4ed9-4e7e-bca1-62be656e3d7e)

State Optimization:
State optimization, also known as state minimization, is the process of identifying and eliminating redundant states in a finite-state machine to simplify its design. 
By removing equivalent states, the number of flip-flops can be reduced, leading to a more efficient and less complex combinational logic. 
Two states are considered equivalent if, for all possible input sequences, the machine produces the same output regardless of the starting state. 
This optimization technique involves comparing states to automate the process efficiently, ensuring that the machine behaves identically regardless of the initial state. 
State optimization is crucial as the number of states in a system increases, making it challenging to distinguish between necessary and redundant states.

dff_cons1.v synthesis:
Here,we can see value of q does not change as soon as reset=0,but q takes the value of 1'b0 at next clock edge,hence here no sequential logic optimization will occur and DFF will be inferred.

    module dff_const1(input clk, input reset, output reg q);
    always @(posedge clk, posedge reset)
    begin
    	if(reset)
    		q <= 1'b0;
    	else
    		q <= 1'b1;
    end
    
    endmodule
    
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/eb13bd68-6736-4f27-ba0a-a958f45480ed)

Synthesis result of dff_const1.v

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/e8d658fe-03f3-43aa-8ff1-c87f374a17eb)

dff_const2.v synthesis:

    module dff_const2(input clk, input reset, output reg q);
    always @(posedge clk, posedge reset)
    begin
    	if(reset)
    		q <= 1'b1;
    	else
    		q <= 1'b1;
    end
    
    endmodule

Here,we can observe the value of q=1'b1 independent of reset input,so upon synthesis,so a DFF will not be inferred upon synthesis.
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9fc437f2-8db3-4a4c-8c9c-8bb5fd0ae916)

Synthesis result of dff_const2.v

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/10dbe5d2-5e27-4b3f-9c60-1f71290585d3)

dff_const3.v synthesis:

    module dff_const3(input clk, input reset, output reg q);
    reg q1;
    
    always @(posedge clk, posedge reset)
    begin
    	if(reset)
    	begin
    		q <= 1'b1;
    		q1 <= 1'b0;
    	end
    	else
    	begin
    		q1 <= 1'b1;
    		q <= q1;
    	end
    end
    
    endmodule

Here,Two DFFs will be inferred with a set flip-flop with q output and reset flip-flop with q1 output and both flip-flops will be connected back to back.
Here,the logic will be retained as the value of q depends upon the state of q1,as seen in the waveform.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f0486019-3b7c-41dd-9b57-88d40d283267)

Synthesis result of dff_const3.v

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/aedb045c-8db7-479d-b5cc-cb93b2fd588d)

dff_const4.v synthesis:
    
    module dff_const4(input clk, input reset, output reg q);
    reg q1;
    
    always @(posedge clk, posedge reset)
    begin
    	if(reset)
    	begin
    		q <= 1'b1;
    		q1 <= 1'b1;
    	end
    	else
    	begin
    		q1 <= 1'b1;
    		q <= q1;
    	end
    end
    
    endmodule

Here,the value of q1 and q are independent of reset input,hence no DFF will be inferred upon synthesis.

Synthesis result of dff_const4.v:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/20d9eaef-d37b-4756-9c98-2893597b6745)

dff_const5.v synthesis:

    module dff_const5(input clk, input reset, output reg q);
    reg q1;
    
    always @(posedge clk, posedge reset)
    begin
    	if(reset)
    	begin
    		q <= 1'b0;
    		q1 <= 1'b0;
    	end
    	else
    	begin
    		q1 <= 1'b1;
    		q <= q1;
    	end
    end
    
    endmodule

Here,after reset is deasserted,q1 is set to 1'b1 at next rising edge of clock,and we see q samples value of q1=1'b1 at the further clk edge,hence q depends upon value of q1,so even if q1 value remains constant,two DFFs will be inferred,as seen in the waveform.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/006c9cf0-d41e-47b5-8f6a-a3224afd5b7e)

Synthesis result of dff_const5.v:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/cb0506c4-aca6-46c7-a838-2aa4b0b3b6fc)

Sequential Optimization for Unused Outputs:

counter_opt synthesis:

Here,we can see q requires only LSB bit of 3-bit count.count[2] and count[2] remain unused.
As it is a 3-bit upcounter,3 flip-flops requirement is there,but due to unused outputs,optimization will be applied and only a single flip-flop will be inferred after synthesis.
Any Logic which  is not resulting in any relationship with any of the primary outputs,will be optimized away as they are unused logic in the design.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/44cbfc91-ea78-43e0-96c3-ec0749513fb9)

    module counter_opt (input clk , input reset , output q);
    reg [2:0] count;
    assign q = count[0];
    
    always @(posedge clk ,posedge reset)
    begin
    	if(reset)
    		count <= 3'b000;
    	else
    		count <= count + 1;
    end
    
    endmodule

Synthesis results of counter_opt:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/11997131-c154-4c92-b4aa-2f0f2841e559)

Synthesis of counter_opt2.v:

    module counter_opt (input clk , input reset , output q);
    reg [2:0] count;
    assign q = (count[2:0] == 3'b100);
    
    always @(posedge clk ,posedge reset)
    begin
    	if(reset)
    		count <= 3'b000;
    	else
    		count <= count + 1;
    end
    
    endmodule

Here,3 flops must be inferred as primary output q has dependence on all the 3 bits of 3-bit upcounter count.

Logic expression we should get for q:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/da715a5c-1031-4491-9d0d-c492b01709a5)

Synthesis result for counter_opt2.v:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9d2e2a04-62d6-413a-b313-c9480e56e37f)

As we can see below in following screenshot and above synthesis results,we got the expected logic implementation for the value of primary output q:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/4f8c4042-415d-42f3-9d56-044a52274793)

</details>

<details>

<summary>Day 4 - GLS, blocking vs non-blocking and Synthesis-Simulation mismatch</summary>

Gate-level simulation is a critical process in digital design, verification, and validation, especially for complex digital systems in modern technology nodes. 
It involves modeling digital circuits at the gate level to understand their behavior accurately. 
Gate-level simulation occurs after synthesis, providing a detailed netlist representation of the circuit with functional and timing characteristics.
This simulation method is essential for dynamic behavior verification, complex timing checks, power efficiency concerns, and design-for-test features integrated at the gate level,ensuring the accuracy of scan chain insertions in DFT. 
Gate-level simulation is crucial for gaining confidence in design and verification, offering a more comprehensive analysis than static methods.
It plays a pivotal role in validating, verifying, and optimizing digital circuits, making it a cornerstone of digital design.

In Gate level Simulation(GLS):
Testbench used for RTL verification is used for netlist simulation,as they are logically same.

Why GLS?

* Verify the correctness of the design after synthesis
* Ensure the timing of the design is met which is done with delay annotation (timing aware)

GLS Flow using iverilog:
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d5e2fe03-8920-4934-98c9-ecedee9a53ca)


Synthesis-Simulation mismatch occurs due to following reasons:

* Missing sensitivity list
* Blocking vs non-blocking assignments
* Non-standard verilog coding

1) Missing Sensitivity List:
   
   Simulator works when change in signals (activity) occurs,and output gets updated.
   If the sensitivity list of always block does not contain all input signals,it will cause mismatches between synthesis and simulation.

   For ex:
   As seen in the screenshot below, in the left column,always block is evaluated only when sel is changing. So output y is not reflecting changes in input i1 and i0 when sel is not changing.
   Rather it acts like a latch.
   The code on the right side represents the correct design coding for mux. In this case always is evaluated for any signal changes.
   
   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/06a66730-57cc-49f6-ae12-a688a4842caf)

2) Blocking vs non-blocking assignments:

   Blocking assignment in SystemVerilog and Verilog refers to an assignment statement where the execution of the next statement is blocked until the current assignment is completed.
   This means that the assignments are executed in series order, one after the other, within a procedural block. In SystemVerilog, blocking assignment uses the "=" operator, while in Verilog, it uses the "<="       operator.
   This type of assignment is commonly used for modeling combinational logic, defining functions, or implementing testbench algorithms.
   It is essential to note that blocking assignment does not prevent the execution of statements running in parallel blocks

   Non-blocking assignment in Verilog allows statements to be scheduled without blocking the execution of subsequent statements. It is denoted by the symbol <= and is particularly useful for describing hardware     systems, especially in synthesis.
   Unlike blocking assignments, non-blocking assignments defer the assignment until all right-hand sides have been evaluated, ensuring simultaneous or parallel statement execution.
   This feature is crucial for sequential logic in Verilog, as it reflects the behavior of multi-stage sequential logic more accurately than blocking assignments.
   In summary, non-blocking assignments are essential for sequential circuits, ensuring that values are updated simultaneously at the end of a time slot, making them ideal for synchronous designs in Verilog.

   For ex:
   As seen in the scrennshot below,the code in left column is correct to achieve our aim of inferrinf two flip-flops but in code in right column,as q is getting directly assigned to d , hence only one flop is 
   inferred.Hence,it it recommended to always use non-blocking statement in always block for sequential logic inference.
   
   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/88dc058a-7886-431c-8e71-a9bfc5abc15f)

   For ex:
   In left column code,y will get old value of q0 during evaluation,which is mimicking the behavour of a flop.
   To get latest value of q0,we can interchange the statements in always block,as seen in right column code.
   Synthesis will produce the same logic implemnetation for both the codes.
   This will lead to synthesis-simulation mismatch.
   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9cf5d027-5e3f-4477-a644-000ae174e870)

   Note:
   Use 'write_verilog <filename>' to write out netlist file in .v format after synthesis is completed.

Synthesis & GLS of ternary_operator_mux:

        module ternary_operator_mux (input i0 , input i1 , input sel , output y);
    	assign y = sel?i1:i0;
    	endmodule

Commands to run GLS after synthesis using iverilog:

    iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_mux_net.v tb_ternary_operator_mux.v #alongwith RTL and testbench files,behavioral models(.v) for 
                std.cell library is also being read in iverilog for GLS
    ./a.out 
    gtkwave tb_ternary_operator_mux.vcd

As we can see in the below results,synthesis of ternary_operator_mux.v infers a mux,which can also be confirmed from the gate-level simulation of the same design.

Synthesis results of ternary_operator_mux:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/2b1be9ab-d6f2-4472-bb05-df2a41c0001d)

GLS waveform for ternary_operator_mux:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/185b7a60-fed4-424b-9aeb-a4ff3c11fe59)


Synthesis of bad_mux (**Synthesis-Simulation Mismatch due to incomplete sensitivity list for always block**) :

    module bad_mux (input i0 , input i1 , input sel , output reg y);
    always @ (sel)
    begin
    	if(sel)
    		y <= i1;
    	else 
    		y <= i0;
    end
    endmodule

    Note:all the input signals of bad_mux are not specified in always block sensitivity list

Synthesis results of bad_mux (we can see above code has inferred a mux in synthesis):

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/1ed8fcf9-0429-4273-811e-29f574912df7)

As we can see in below screenshot,
* In RTL simulation (bottom waveform),the bad_mux design is not propagating the changes in the input signal i0 and i1 to output y whenever sel signal is static .i.e has no activity or transitions,only when sel transitions,the input signal values are being propagated to output.
* Whereas in GLS of bad_mux (top waveform),we see that a proper mux_behaviour is being exhibited. Hence,here we can observe that Synthesis-Simulation mismatch has occurred due to incomplete sensitivity list of always block.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/8271352c-942d-4189-9c5a-0b94193dc9aa)

Synthesis of blocking_caveat (**Synthesis-Simulation Mismatch due to improper usage of blocking statements**) :

    module blocking_caveat (input a , input b , input  c, output reg d); 
    reg x;
    always @ (*)
    begin
    	d = x & c;
    	x = a | b;
    end
    endmodule

Synthesis results of blocking_caveat :

As we can see logic has been inferred by tool as we have predicted in below screenshot:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/b4840cbd-be90-41f8-91ab-d43ac48c5941)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/62e7c368-23bf-407c-9f4d-038fde84b959)

As we can observe in the following screenshot,
* In RTL Simulation (bottom waveform) , at 1100ns the value of d is not getting computed with latest value of x,rather it is computed with previous value of x.
* In GLS (top waveform), at 1100ns the value of d is computed with latest value of all signals,hence we can conclude synthesized netlist is behaving according to our prediction.
  Hence we observe Synthesis-Simulation Mismatch for this design due to improper usage of blocking statements.
   
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f3b7d1df-79ee-43d0-b123-7681e4700918)

</details>

<details>

<summary>Day 5 - Design for Test (DFT)</summary>


Introduction to Design for Test (DFT) :

Design for Test (DFT) is a crucial aspect of electronic system design that focuses on incorporating testability features into the hardware and software of a product. 
The primary goal of DFT is to ensure that the final product can be thoroughly tested, both during the manufacturing process and throughout its lifetime, to identify and address any defects or issues.

Key Principles of DFT :
* Accessibility: Designing the system in a way that allows easy access to internal components and signals for testing purposes.
* Controllability: Ensuring that the system can be driven into specific states or conditions to facilitate comprehensive testing.
* Observability: Enabling the observation and monitoring of internal signals and states during the testing process.
* Testability: Incorporating features that simplify the testing process, such as built-in self-test (BIST) mechanisms or scan chains.
  
Benefits of Implementing DFT :

* Improved Product Quality: DFT helps identify and address defects early in the design process, reducing the risk of shipping faulty products.
* Reduced Manufacturing Costs: Effective testing during manufacturing can catch issues before they become more expensive to fix, leading to cost savings.
* Faster Time-to-Market: By incorporating DFT principles, the testing process can be streamlined, allowing for quicker product development and deployment.
* Easier Maintenance and Troubleshooting: DFT features can aid in the diagnosis and repair of issues during the product's lifetime, improving overall reliability and serviceability.

DFT Techniques and Methodologies :

Some common DFT techniques and methodologies include:
* Scan-based Testing: Inserting scan chains to allow for the controllability and observability of internal logic.
* Built-in Self-Test (BIST): Incorporating self-testing capabilities directly into the hardware or software.
* Boundary Scan (IEEE 1149.1): Using a standard interface to access and control the pins of integrated circuits for testing purposes.
* Design for Testability (DFT) Automation: Leveraging EDA tools to automate the incorporation of DFT features during the design process.



Basic Terminologies to be known about DFT:

**Defect** - A defect in an electronic system is the unintended difference between the implemented hardware and its intended design.

Some typical defects in VLSI chips are :
1. Process Defects – missing contact windows, parasitic transistors, oxide breakdown,etc.
2. Material Defects – bulk defects (cracks, crystal imperfections), surface impurities,etc.
3. Age Defects – dielectric breakdown, electromigration, etc.
4. Package Defects – contact degradation, seal leaks, etc.

**Error** - A wrong output signal produced by a defective system is called an error. An error is an “effect” whose cause is some “defect”.

**Fault** - A representation of a “defect” at the abstracted function level is called a fault.

**Controllabilty** - From DFT point of view,Controllability means we intend if both '0' and '1' are able to propagate to wach and every node within the target patterns.
                     A point is said to be controllable if both '0' and '1' can be propagated through scan patterns.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/59c799c4-4e99-4fba-8003-e685e32abb4a)


**Observabilty** - By observability, we mean our ability to measure the state of a logic signal. When we say that a node is observable, we mean that the value at the node can be shifted out through scan patterns                    and can be observed through scan out ports.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/35db1a01-7024-468d-a902-4f7e2995ec6a)

**Fault Coverage** - Percentage of the total number of logical faults that can be tested using a given test set T.

**Defect Level** - It refers to the fraction of shipped parts that are defective or the proportion of the faulty chip in which fault is not detected and has been classified as good.

DFT Techniques :

Ad-hoc Techniques : 

The adhoc DFT relies on “good” design practices learned from experience. Some of these are:

• **Avoid asynchronous logic feedbacks.** A feedback in the combinational logic can
give rise to oscillation for certain inputs. This makes the circuit difficult to
verify and impossible to generate tests for by automatic programs. This is
because test generation algorithms are only known for acyclic combinational
circuits.

• **Make flip-flops initializable.** This is easily done by supplying clear or reset
signals that are controllable from primary inputs.

• **Avoid gates with a large number of fan-in signals.** Large fan-in makes the
inputs of the gate difficult to observe and makes the gate output difficult to
control.

• **Provide test control for difficult-to-control signals.** Signals such as those produced
by long counters require many clock cycles to control and hence increase
the length of the test sequence. Long test sequences are harder to generate.

Structured DFT :

* Structured DFT is performed by using Scan flip-flops.

* The main idea in scan design is to obtain control and observability for flip-flops.

* This is done by adding a test mode to the circuit such that when the circuit is in this mode, all flip-flops functionally form one or more shift registers. 

* The inputs and outputs of these shift registers (also known as scan registers) are made into primary inputs and primary outputs. 

* Thus, using the test mode, all flip-flops can be set to any desired states by shifting those logic states into the shift register. 

* Similarly, the states of flip-flops are observed by shifting the contents of the scan register out. All flip-flops can be set or observed in a time (in terms of clock periods) that equals the
number of flip-flops in the longest scan register.

**What is the purpose of scan flops?**

There are various reasons, but 2 main reasons are noted below:

* To test stuck-at faults in the manufactured devices.
* To test the path in the manufactured devices for delay that is to test whether each path is working at a functional frequency or not.

Types of Scan flip-flops:

1) Multiplexed Scan cell :
   
   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/2405a90b-6677-40d1-b032-67511754c6be)

3) Clocked Scan cell:
   
   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/b430e73b-1a83-44af-a525-de1eec8b28f8)

4) LSSD Scan cell:
   
   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/23e036c5-3052-492a-9c27-fbaedbb27af2)
   
Scan chain : A scan chain is a serial interconnection of scan flip-flops within a digital circuit. It forms a shift register-like structure that enables the sequential access and manipulation of the internal states of flip-flops in the circuit for testing and debugging purposes.

Here's how a scan chain works:

* Interconnection: In the scan chain, each scan flip-flop is connected to the next one in the chain, forming a serial path that traverses through all the flip-flops within the circuit.
* Shift-In/Shift-Out: The scan chain allows for the serial shifting of data into and out of the flip-flops. Test patterns can be shifted into the chain to set the initial states of the flip-flops for testing. 
                      Similarly, the current states of the flip-flops can be serially shifted out for observation or comparison.
* Test Patterns: Test patterns generated by automatic test pattern generation (ATPG) tools or other testing methods can be applied to the scan chain to detect faults within the circuit, such as stuck-at faults, 
                 transition faults, and bridging faults.

**How long one scan chain be?**
The length of a scan chain in a digital circuit can vary depending on several factors, including the design requirements, the complexity of the circuit, and practical limitations imposed by the technology and implementation.

In theory, there is no strict limit to the length of a scan chain, and it can span hundreds or even thousands of flip-flops in a very large integrated circuit. However, longer scan chains can present challenges in terms of testing speed, power consumption, and signal integrity.

Here are some considerations regarding the length of a scan chain:

* Testing Speed: As the length of the scan chain increases, the time required to shift in or shift out test patterns also increases. Longer scan chains can result in longer test times, which may be undesirable for production testing or design validation.
* Power Consumption: Each flip-flop in the scan chain consumes power during shifting operations. Longer scan chains may result in higher power consumption, which can be a concern in low-power designs or battery-operated devices.
* Signal Integrity: In longer scan chains, signal integrity issues such as propagation delay, skew, and crosstalk become more significant. Proper design techniques, such as buffer insertion and routing optimizations, may be necessary to mitigate these issues.
* Design Constraints: Practical limitations imposed by the technology and implementation may restrict the length of a scan chain. For example, limitations in routing resources, timing constraints, or the available space on the integrated circuit may impose constraints on the maximum achievable scan chain length.

**No. of scan ports(scan_in and scan_out) required = 2 * no. of scan chains.** because each scan chain requires its' own scan_in & scan_out port

Note:

**Number of cycles required to run a pattern = Length of longest scan chain**

![Screenshot 2024-05-05 210828](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/4bb60ed6-7f97-4325-8451-e1b98e559992)


  

**Why do we use ATPG?**
* Automatic Test Pattern Generation (ATPG) is utilized in Very Large Scale Integration (VLSI) to ensure the correctness and quality of Integrated Circuits (ICs).
* ATPG is essential because it automates the process of generating test patterns that can detect faults in the circuit, making it cost-effective, time-saving, and crucial for the design and testing phase of VLSI 
  circuits.
* The complexity of VLSI circuits, with millions of transistors on a single chip, makes manual testing impractical.

**What is ATE?**

* Automatic Test Equipment (ATE) is computerized machinery that automates the testing of electronic devices and systems, evaluating functionality, performance, quality, and stress tests. ATE uses test instruments to carry out these evaluations with minimal human interaction, ensuring adequate performance and safety of electronic devices. 
* The components of an ATE system typically include hardware, software, test instruments, signal sources, and test probes or handlers. 
* Industries use ATE extensively, including defense and aerospace, automotive, and industrial automation, to validate electronics before deployment or sale. ATE plays a crucial role in ensuring end-users receive 
  devices that function as intended and are safe to use.

**When and where the DFT design is included?**

* When is it included? - At the beginning of the  design flow

* Where exactly ? - during the synthesis flow

Synopsys Tool used for DFT insertion is DFT Compiler:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d991a5cb-e264-41c4-a9b7-4fa02112551f)

### Introduction to Synopsys Tools to be used for further exercises:

1) Design Compiler:
   
   Design Compiler is a synthesis tool developed by Synopsys, a leading electronic design automation (EDA) company. It is widely used in the semiconductor industry for RTL (Register Transfer Level) synthesis, 
   which is the process of converting a high-level hardware description of a digital circuit into a gate-level netlist.

   Commands to start Design compiler are:
   
       dc_shell # invokes design compiler tool
       start_gui # starts the GUI of the tool

   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/498c7d6b-b780-44d7-b62d-cde1e12c2e85)

2) Library compiler:
    
    The Synopsys Library Compiler is a software tool used in the design and development of ICs. It automates the process of creating and characterizing semiconductor intellectual property (IP) libraries, which 
    are collections of reusable building blocks used in IC design. These libraries contain pre-designed functional blocks such as logic gates, memory cells, and analog circuits.
    
    The Library Compiler allows designers to generate these libraries efficiently, taking into account various parameters such as process technology, voltage, temperature, and operating conditions. It also 
    includes features for optimizing library performance, minimizing power consumption, and ensuring compatibility with industry standards.

Commands to start Library compiler are:
   
       lc_shell # invokes library compiler tool
       start_gui # starts the GUI of the tool

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f59d09a8-1e2a-43e1-892a-52e19a0ca958)

3) ICC2 Compiler:

    The ICC2 Compiler, developed by Synopsys, is a tool used in the process of physical design for integrated circuits. ICC2 stands for "Integrated Circuit Compiler 2". It's primarily utilized in the backend 
    stages of the IC design flow, which involve translating a logical representation of a circuit (usually in the form of a netlist) into a physical layout that can be fabricated.

   Commands to start ICC2 compiler are:
   
       icc2_shell # invokes icc2 compiler tool
       start_gui # starts the GUI of the tool

   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/5acbdbeb-9264-4d32-b886-120d07ff9668)

</details>

<details>

<summary>Day 6 - Introduction to Logic Synthesis</summary>

Tools to be used for this course :

1) iverilog - For Verilog Compilation and Simulation
2) gtkwave - For viewing Simulation Output
3) Synopsys Design Compiler - For Logic Synthesis
4) Skywater 130nm Library

Objectives of this Course :

1) Understand various steps in Logic Synthesis.
2) Understand and write SDC (Synopsys Design Constraints) for a given design module.
3) Perform Synthesis and write out netlist using Design Compiler.
4) Generate and Analyze the Synthesis reports/STA reports.

**What is Logic Synthesis?**

Logic Synthesis is the process of converting RTL description of design into Gate-level netlist.
The design is converted into gates and the connections are made between the Gates.
This is given out as a file called netlist.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/017f0d06-6464-4e1c-95d4-4a08b127c4af)

**What is .lib?**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3c02c1ad-85f6-46a8-b58c-29b0be08044a)

**Why Different Flavors of gate are required?**

* Different flavors of gate are required because the delay of combo logic between flops determines maximum speed of operation (clock frequency) of our design.
* Smaller the combinational delay,larger can be the clock frequency,which can be achieved by using faster cells.
* But, we also need to meet our hold tome requirement for flops,so that data should not come within the hold window of a flop.Here the need arises for slower cells.
* Hence,both faster and slower cells are used to meet our target clock frequency while avoiding hold time violations in our design.
* These cells collectively form our std. cell library and their timing and logical information is used by tools,in the form of .lib format.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/ecfeda1e-507f-4ac8-9b01-67554efbf9a7)

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a9181229-0291-4a60-a5aa-6db8ff171c37)



**Faster Cells vs Slower Cells** :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/8a08a070-6f55-40a5-be98-59920227025d)

**How Cells are Selected?**

We provide guidance to the Synthesizer,using **Constraints** to select the flavor of cells which will be optimum for the implementation of logic circuit.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a9670d1d-527a-47b7-af11-fba00ee85c90)

Logic Synthesis Example:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f41a7a71-bce1-4f60-aaa6-029f12e13564)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c9262826-3b95-4583-81e1-a5443c6c8cee)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/5fc69a2f-b72b-4463-9351-9c43e2e8e21e)

* From above we can see implementation 3 provides least area and delay among all,but is it the best?
* If implementation 3 is present in hold sensitive path,additional buffers have to be added to meet hold timing,leading to increase in area and power of design.
* So,here the **Significance of Constraints** come into picture.
* Any one of the above three implementations may be picked by the synthesizer,as per need,guided by the **constraints** provided by the designer.

#### Introduction to Design Compiler

**What is Design Compiler (DC)?** :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3b02546c-f9ec-44c8-bfe7-b741e89b60c1)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d97ccbe5-f5e1-4e11-adbb-17675bab8c89)

**What are Synopsys Design Constraints (SDC)?**
* Synopsys Design Constraints (SDC) is a format used to specify the design intent, including timing, power, and area constraints for a design. 
* This format is based on the tool command language (Tcl) and is used by various EDA tools to synthesize and analyze a design. 
* The SDC format is employed to define the performance goals for a design, ensuring that the design meets its intended specifications and constraints. 
* It is a crucial step in the design process, as it helps in optimizing the design for timing, power, and area, which are critical factors in the development of integrated circuits.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/91bea377-3a0c-4ea6-982d-ea5d02f2d95f)

Implementation Flow of ASIC : Steps for converting RTL to Physical Database (GDS) :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c11cfb52-83a3-40a2-9d4c-998647bad233)

**DC Synthesis Flow** :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/390a85d4-01e6-489e-afed-b746b6644913)

**Design.lib** are .lib representations of any 3rd party IP used in our design,which has to be provided as input to DC tool,for implementation of the IP in our design.

#### Lab 1 - Invoking DC Basic Setup :

Synthesis Labs are being performed in this directory : `/home/subhasis/Synthesis_labs/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP`

Commands to invoke DC are : 

    csh # to invoke c shell
    dc_shell # to invoke DC tool

target_library - It specifies the library of std. cells for a particular technology to be used by DC tool during technology mapping and optimization phase of synthesis.

link_library - It contains the set of design entities,i.e,any std. cell,PLL,SRAM,Analog IPs which are directly instantiated in RTL,and is used by DC tool to resolve these references.These entities are not used 
               during technology mapping phase.

* When we echo the target_library and link_library variables in dc_shell we see they are pointing to `your_library.db` and `* your_library.db` respectively,which are non-existent imaginary libraries.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/fe0b0d8f-52ff-4f60-b3df-ef270b98aea5)

RTL code for lab1_flop_with_en :

    module lab1_flop_with_en ( input res , input clk , input d , input en , output reg q);
    always @ (posedge clk , posedge res)
    begin
    	if(res)
    		q <= 1'b0;
    	else if(en)
    		q <= d;	
    end
    endmodule

`read_verilog verilog_files/lab1_flop_with_en.v` - Command used to reads design information from Verilog files into memory. it does the work of both `analyze` and `elaborate` command in single step.

`write -f verilog -out verilog_files/lab1_net.v` - write the netlist in verilog format.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a997772b-da03-4f7a-a0c7-f7b0f4f2844e)

We can see in above screenshot
* DC has internal virtual libraries in .db format to understand the design being read.The libraries are `gtech.db` and `standard.sldb`
* We can observe after reading the RTL file,DC is invoking `Presto HDL Compiler` for RTL compilation purposes.
* As the `your_library.db` is a dummy library,it is not able to link with current design
* In this line `Compiling source file /home/subhasis/Synthesis_labs/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/verilog_files/lab1_flop_with_en.v` , DC tool has inferred a flip flop with async reset,after 
  compilation

After writing out the netlist, we can observe in below screenshot,that the tool has currently synthesized our design using generic technology independent cells,which are part of GTECH library of DC to produce the netlist.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d1e059fd-ef14-4f95-9591-fa46cd70c7f9)

To get a proper technology mapped netlist,we need to specify our technology library for the target_library and link_library variables.

`set target_library lib/sky130_fd_sc_hd__tt_025C_1v80.db` # set our target technology library path in .db format,as DC understands .db format (binary form of .lib) only

`set link_library {* lib/sky130_fd_sc_hd__tt_025C_1v80.db}` # set link library path. * denotes all the libraries which already are loaded in DC and the new library path will be appended to the list of libraries 
                                                                                       without overwriting

`link` command is used after specifying target and link libraries,to link our design with the libraries specified.

`compile` command is used to perform logic-level and gate-level synthesis and optimization on the current design.

After `compile` command when we write out the netlist we can see that the correct technology specific cells have been used by the tool for implementing our design,as seen in below screenshot :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/176a4853-8fc0-4996-8f49-f0cded69979e)

#### Lab 2 - Intro to ddc gui with design_vision :

`.ddc` - .ddc consists of the same information as a .db file. ddc is a synopsys encrypted form of our design which can be read by the tools such as Design compiler, IC compiler and prime time. It consists of             the netlist(list of components and nets) information of our design , .db libraries (target and link) used, along with the constraints which we have specified for implementing the design.

**What is Design Vision?**

* The Design Vision tool is the graphical user interface (GUI) for the Synopsys logic synthesis environment. 
* Design Vision provides analysis tools for viewing and analyzing your design at the generic technology (GTECH) level and the gate level. 
* It also provides all of the synthesis capabilities of the Design Compiler tool. Design Vision provides menu commands and dialog boxes for the most commonly used synthesis features. 
* In addition, we can enter any dc_shell command on the command line in the GUI or the shell.

Commands to generate .ddc file and read it in design vision tool:

      After Synthesis has been performed using DC shell,
      write -f ddc -out lab1_net_with_sky130.ddc # writes out .ddc file for current design
      design_vision # invokes design vision tool , invoke after exiting DC shell or in new terminal window/tab
      read_ddc lab1_net_with_sky130.ddc # read the design information for the specified .ddc file

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3f727f58-9c97-451c-b304-106d0fedf809)

We can read verilog files also in design_vision by using `read_verilog` command ,but after reading the netlist in .v format in design vision, we can notice that only gtech.db generic library file is being read instead of our technology specific skywater130nm .db library file.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/16573c82-f863-43db-a0fa-7e719d4052b6)

We can also see schematic view of our design in design vision :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/525f5fbb-d2ee-427e-b119-519c3910be4d)

As we can see this is also matching what we expected for our design a DFF with asynchronous reset with mux with enable input at DFF input d :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/0f2a6828-7000-4ce1-b894-67bd09353d63)

#### Lab 3 - dc synopsys setup :

* When we have design with multiple .db libraries , it is very cumbersome & error-prone to set target_library and lInk_library manually, as we cannot miss even one .db library
* So to solve the above issue, all repetitive tasks ( setting target and link libraries) which is essential for tool setup can be put in a single file ,called `.synopsys_dc.setup`.
* `.synopsys_dc.setup` can be present in two locations
    * First,in DC tool install directory which is the default one to be picked by DC tool
    * Second, can be created in user home directory,and which when present will be read by DC tool for setup instead of the default one present in its' install directory.
 
As we can see in below screenshot,without any changes to `.synopsys_dc.setup` file , default target and link library set by DC tool is dummy library `your_library.db`

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/b9baeb21-fa2b-4498-b65d-9e073c36099a)

After creating and adding commands to set target library and link library in `.synopsys_dc.setup` file in user home directory, we can observe that the target and link library are being automatically set according to the commands specified in `.synopsys_dc.setup` file.

`.synopsys_dc.setup` file screenshot :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/03f53f96-d71c-4ede-9664-6f14a67c4f83)

dc_shell screenshot after creating `.synopsys_dc.setup` file in home directory :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c8e9ec1e-c2fe-4f08-b8df-60ef2708206d)

**Note :**

If the file  `.synopsys_dc.setup` is either moved from home directory or its' name is altered in any manner, it will not be read by dc_shell when the tool is being invoked.

## Quick TCL Refresher :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/83be5816-42da-40c5-a5a0-a363b5bac300)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/08d9d329-23f8-4700-8731-3846434e57c0)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/16b433ec-1cd1-4fe5-b336-ba11301ab8fb)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f10dc251-6123-437b-82cf-0dd6d4c55ac8)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9030864d-b5f9-44c2-97a7-044968942837)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/df9b4d3c-1661-4000-ace2-802ec50e36de)

## Lab 4 : TCL Scripting :

Using few TCL commands in dc_shell : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/b4ed204d-424f-4b55-b6f1-f3c11da7701c)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/bddd0f6c-908e-40f4-a79e-c27cced40af4)

`get_lib_cells */*and*` - In dc_shell, it  Creates  a collection of library cells from the libraries loaded into memory. This  command  creates a collection of library cells from the libraries
                          currently loaded into memory that match the specified criteria (either with patterns option or -of_objects option) 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/78e19865-3941-4a56-b241-7eee80fbbf6a)

`foreach_in_collection` - The  foreach_in_collection command is used to iterate over each element in a collection.  We cannot use the Tcl-supplied  foreach  command  to iterate  over  collections because the 
                          foreach command requires a list, and a collection is not a list.  Also, using the foreach command  on  a collection causes the collection to be deleted.

When we execute the foreach_in_collection command in the manner as shown below,we can see the collection is not exactly like a list,and the collection is containing objects which are pointing to some entities,analogous to pointers in C programming Language : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/1888d8df-4c10-47ef-85cf-d226fc987f49)

So,to print the value of the objects in collection,execute as shown below : 

    foreach_in_collection my_var [get_lib_cells */*and*] {                                                                                                                     
    set my_var_name [get_object_name $my_var]; echo $my_var_name;    # iterate over the collection and get the object name assigned to aparticular object and print it on the screen.                                                                                                            
    }

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/4045303e-d4d2-4462-95c5-827418496f34)


We can also put the TCL commands and dc_shell commands we want to execute in a .tcl script and source it in dc_shell for execution (very helpful to automate repetitive tasks or create automation flow to aid in 
design) : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/77b0f524-0efc-4d5f-9257-00dfe458d928)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c4ce617e-2d89-453b-8bd8-cfcfd824a2b7)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/599a47a0-f438-4d72-b043-cae36d4e1c82)

**Note :**

When data is  printed on screen with {} , it means it is a DC collection,not a TCL list.

</details>

<details>

<summary>Day 7 - Basics of Static Timing Analysis</summary>

#### **What is STA?**

* Static Timing Analysis (STA) is a method of validating the timing performance of a digital circuit design by checking all possible paths for timing violations under worst-case conditions. The key points about 
  STA are:
  
    * It breaks down the design into timing paths, calculates the signal propagation delay along each path, and checks for violations of timing constraints inside the design and at the input/output interface.
    * STA considers the worst possible delay through each logic element, but does not simulate the logical operation of the circuit. This makes it faster than dynamic simulation, which requires simulating 
      multiple test vectors.
    * The goal of STA is to verify that despite variations in factors like input data, temperature, voltage, and manufacturing, all signals will arrive at the correct time - not too early or too late.
    * STA checks for two types of timing violations: setup time violations (where a signal arrives too late) and hold time violations (where a signal changes too soon after the clock edge).
    * STA is an essential part of the integrated circuit design process, allowing timing issues to be identified and fixed before manufacturing, improving first-pass silicon success.

#### Setup Timing Check : 

* A **setup timing check** verifies the timing relationship between the clock and the data pin of a flip-flop so that the setup requirement is met. 
* In other words, the setup check ensures that the data is available at the input of the flip-flop before it is clocked in the flip-flop. 
* The data should be stable for a certain amount of time, namely the setup time of the flip-flop, before the active edge of the clock arrives at the flip-flop.
* This requirement ensures that the data is captured reliably into the flip-flop. The below figure shows the setup requirement of a typical flip-flop.
* A setup check verifies the setup requirement of the flip-flop.

    ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/548c6735-e1b5-4df4-8769-12e982a95434)

* In general, there is a launch flip-flop - the flip-flop that launches the data, and a capture flip-flop - the flip-flop that captures the data whose setup
  time must be satisfied.
* The setup check validates the long (or max) path from the launch flip-flop to the capture flip-flop.
* The clocks to these two flip-flops can be the same or can be different.
* The setup check is from the first active edge of the clock in the launch flip-flop to the closest following active edge of the capture flip-flop.
* The setup check ensures that the data launched from the previous clock cycle is ready to be captured after one cycle.

* We now examine a simple example, shown in Figure given below, where both the launch and capture flip-flops have the same clock.
    * The first rising edge of clock CLKM appears at time Tlaunch at launch flip-flop. The data launched by this clock edge appears at time Tlaunch + Tck2q + Tdp at the D pin of the flip-flop UFF1.
    * The second rising edge of the clock (setup is normally checked after one cycle) appears at time Tcycle + Tcapture at the clock pin of the capture flip-flop UFF1. The difference between these two times 
      must be larger than the setup time of the flip-flop, so that the data can be reliably captured in the flip-flop.
  
* The setup check can be mathematically expressed as:
  `Tlaunch + Tck2q + Tdp < Tcapture + Tcycle - Tsetup`
  
  where Tlaunch is the delay of the clock tree of the launch flip-flop UFF0, Tdp is the delay of the combinational logic data path and Tcycle is the clock period. Tcapture is the delay of the clock tree for the 
  capture flip-flop UFF1.

* In other words, the total time it takes for data to arrive at the D pin of the capture flip-flop must be less than the time it takes for the clock to travel to the capture flip-flop plus a clock cycle delay 
  minus the setup time.
  
* Since the setup check poses a max  constraint (It imposes an upper bound on the data path delay), the setup check always uses the longest or the max timing path. For the same reason, this check is normally 
  verified at the slow corner where the delays are the largest.

    ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/ff8fe272-9e57-4589-86a9-4d2562930767)

#### Hold Timing Check :

* A hold timing check ensures that a flip-flop output value that is changing does not pass through to a capture flip-flop and overwrite its output before the flip-flop has had a chance to capture its original 
  value. 
* This check is based on the hold requirement of a flip-flop. The hold specification of a flip-flop requires that the data being latched should be held stable for a specified amount of time after the active 
  edge of the clock.
* Below figure shows the hold requirement of a typical flip-flop.

     ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/8d04e77b-c842-42bc-903e-016004d75ae5)

* Just like the setup check, a hold timing check is between the launch flip-flop -the flip-flop that launches the data, and the capture flip-flop - the flip-flop that captures the data and whose hold time must 
  be satisfied.
* The clocks to these two flip-flops can be the same or can be different. The hold check is from one active edge of the clock in the launch flip-flop to the same clock edge at the capture flip-flop. Thus, a 
  hold check is independent of the clock period. The hold check is carried out on each active edge of the clock of the capture flip-flop.


* In the example given below,
    * Consider the second rising edge of clock CLKM. The data launched by the rising edge of the clock takes Tlaunch + Tck2q + Tdp time to get to the D pin of
      the capture flip-flop UFF1.
    * The same edge of the clock takes Tcapture time to get to the clock pin of the capture flip-flop.
    * The intention is for the datafrom the launch flip-flop to be captured by the capture flip-flop in the next clock cycle. If the data is captured in the same clock cycle, the intended data in the capture 
      flip-flop (from the previous clock cycle) is overwritten.
    * The hold time check is to ensure that the intended data in the capture flip-flop is not overwritten. The hold time check verifies that the difference between these two times (data arrival time and clock 
      arrival time at capture flip-flop) must be larger than the hold time of the capture flip-flop, so that the previous data on the flip-flop is not overwritten and the data is reliably captured in the flip- 
      flop.

* The hold check can be mathematically expressed as: `Tlaunch + Tck2q + Tdp > Tcapture + Thold`
  
* where Tlaunch is the delay of the clock tree of the launch flip-flop,
* Tdp is the delay in the combinational logic data path and Tcapture is the delay on the clock tree for the capture flip-flop.
* In other words, the total time required for data launched by a clock edge to arrive at the D pin of the capture flip-flop must be larger than the time required for the same edge of the clock to travel to the 
  capture flip-flop plus the hold time. This ensures that UFF1/D remains stable until the hold time of the flip-flop after the rising edge of the clock on its clock pin UFF1/CK.

    ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/774f96b8-45e9-4a95-9fe6-ac92d8c00754)


* The hold checks impose a lower bound or min constraint for paths to the data pin on the capture flip-flop; the fastest path to the D pin of the capture flip-flop needs to be determined. This implies that the 
  hold checks are always verified using the shortest paths. Thus, the hold checks are typically performed at the fast timing corner.

#### **On which factors delay of a cell depends on?**

The delay of a cell depends on :
 1) Input Transition (Faster Input Transition due to larger charging current leads to faster charging/discharging of output node, load capacitance remaining constant)
 2) Output Load (Lower load capacitance at output node of cell leads to less time for charging/discharging the node,provided driving current/input transition remains constant)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d6e99f09-fc93-4f26-9da0-2f58aa56c618)

#### **What are Timing Arcs?**

A timing arc represents the timing relationship between pins of logic cells.It is a segment or component of a timing path that may contribute to the delay in signal propagation along the path.

The key points about timing arcs are:

* Each cell can have multiple timing arcs, as a signal may propagate through different paths within the cell.
* Timing arcs are used by static timing analysis (STA) tools to calculate the delay through a path.
  
There are two main types of timing arcs:
* Delay arcs: Used to calculate propagation delay, including cell delay arcs and net delay arcs.
* Constraint arcs: Used to define timing relationships between pins, such as setup, hold, recovery and removal checks

* Timing arcs have a source pin (where the arc originates) and a sink pin (where it ends).
  
* The timing sense or unateness of an arc describes the relationship between transitions at the source and sink pins :
    * Positive unate: Rise at source causes rise at sink.
    * Negative unate: Rise at source causes fall at sink.
    * Non-unate: No simple relationship between source and sink transitions.
 
  Ex. of Timing arcs for combinational cells :

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/7f8b9663-ff50-430e-ad4c-a795c36c7d92)

  Ex. of Timing arcs for sequential cells :

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/98695f59-45c8-452b-917f-af4e879ece6e)

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c14e6583-eca5-434c-b1ca-40636b3856a8)

  **Note :**

  For Sequential cells, Setup and hold constraint arcs are always around/calculated around sampling point of the clock waveform.

  1) For DFFs, for Setup and hold constraints arcs, sampling point are calculated from the respective clock edge according to the flip-flop (posedge or negedge) used.
  2) For DLATs (D-Latches),
     * For positive latch, setup and hold constraint arcs are from negedge of clock (The point where latch transitions from transparent state to opaque state)
     * For negative latch, setup and hold constraint arcs are from posedge of clock (The point where latch transitions from transparent state to opaque state)

#### **What are Timing Paths?**

The concept of timing paths in VLSI design is crucial for ensuring proper timing performance. Timing paths are defined as the paths between start points and end points in a design, where the timing requirements need to be met within a clock cycle. Different types of timing paths include Input to Register, Input to Output, Register to Register, and Register to Output paths. Each type has specific characteristics and requirements:

* Input to Register Path: This path starts at an input port and ends at the data input of a sequential element. It is semi-synchronous, where the register is controlled by the clock, and input data can arrive 
  at any time.
* Register to Register Path: In this purely sequential path, both the starting and ending flops are controlled by the clock.
* Register to Output Path: Data can arrive at any point in time in this path, starting at the clock pin of a sequential element and ending at an output port.
* Input to Output Path: This pure combinational path starts at an input port and ends at an output port.

* Moreover, timing paths can be further categorized into Clock Paths, Clock Gating Paths, and Asynchronous Paths based on their characteristics. Clock paths involve the traversal of clock signals, clock 
  buffers, and clock inverters. Clock gating paths introduce additional advantages by passing through gated elements.
* Asynchronous paths, on the other hand, involve paths from input ports to asynchronous set or clear pins of sequential elements.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/ef401b83-a1df-4f25-b27d-57cbe11e75d4)
  
  The valid paths in above figure are:
  
   * input port A to UFFA/D
   * input port A to output port Z
   * UFFA/CLK to UFFB/D
   * UFFB/CLK to output port Z

#### **Why Constraints are used?**

We use design constraints (Timing Specifications,constraints related to area,power etc.) to guide the synthesizer, to choose the correct flavor of std. cells from our std. cell library, which will help in
implementing our design in the most optimized manner,while adhering to our goals of **PPA (Power,Performance & Area)**.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c3813386-8d14-4b27-9dbb-46dbc613b80b)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/278d21ef-baab-4bc7-a2c5-7c57e4c5c665)

Need for constraining Input and Output paths apart from REG2REG paths :

We need to constrain IO paths to optimize our input and output combinational logic for delay, to `meet timing for REG2REG paths which are observed when we look beyond our design boundary`.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/edeffc7b-ba1a-44fd-ae36-e9323f12c6bf)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/abf53852-77ae-412e-9c9a-e0ad259f107f)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/6b3601c9-5e9c-40ce-9cfd-87d6d930d20b)


Summary of Constraints so far : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/04593d46-66f9-4ed8-90eb-d9e642ff54ad)

**Note :**

**How IO delay modelling is done?**

    * By delay specifications provided for standard interfaces such as SPI,I2C etc.
    * By IO Budgeting based on Interactions with Different modules/blocks present in the design.

#### IO Constraints :

**Is IO delay modelling sufficient for meeting timing of our design?**

* As the `transition of input signals` coming into our design are `not ideal`, we have to inform the DC tool/Synthesis tool through constraints the `characteristics (transition)` of our input signals, otherwise 
  we may face timing violations on IO paths. **(Because cell delay is a function of input transition)**
* By this input transistion info, proper delays can be modelled and measured by the tool at Input ports,which will help the tool in optimizing our design to meet our timing goals.
* This is an example of time budgeting/IO budgeting.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/00efc736-813f-4a60-bd47-62304bfcbb89)

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d5ea106b-8073-4e4d-857f-31388660b8c5)

**Is IO delay modelling and Input Transition modelling enough for meeting timing of our design?**

* As the load driven by the output logic is non-zero, and as we know cell delay is also a function of output load capacitance, hence output load modelling at output ports becomes crucial to achieve our timing
  targets for our design.
* Hence,we have to provide this output load info to DC/Synthesis tool , so proper cell delay for output logic connected to output port can be estimated and design can be optimized accordingly, to meet our 
  timing targets. 

 ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/e99e3085-0986-497f-8f51-7ad07efb9298)
 

 ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/cc5d74b4-5433-4b35-a940-6ab36d44ba24)

 **Similar to IO delay modelling, Input Transition and Output Load modelling is also done by :**

    * By  specifications provided for standard interfaces such as SPI,I2C etc.
    * By IO Budgeting based on Interactions with Different modules/blocks present in the design.

As a general rule of thumb, 70% of clock period is set aside for external delay and 30% of clock period is set aside for internal delays. **(Note : This is not applicable for all scenarios and for all 
designs)**.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/1786a0e3-46c1-4d35-a710-66df0d99116b)

**Note :**

IO paths have to be constrained for both Max Delay (Setup) and Min Delay (Hold).

#### Lab 1 - Timing .libs :

* Timing libraries (.lib) are ASCII representations of the timing, power, and area associated with standard cells in VLSI physical design. 
* They are generated by characterizing cells under different PVT (process, voltage, and temperature) conditions, which results in delay calculations based on input transition (slew) and output capacitance 
 (load).

* A .lib file typically contains three major parts: global definition, cell definition, and pin definition.
* The global definition includes information about the library, technology, delay model, and library features.
* The cell definition includes details about each cell, such as its area.
* The pin definition includes details about each pin, including its direction and capacitance.

As we can see in the screenshot below, the various information like the name of the library,technolgy used (CMOS or others), PVT info, default values of max_transition,capacitance,fanout_load,units of time,capacitance,resistance,voltage etc. can be observed : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/22e58ecb-ccad-4bb7-82e7-b69477b9cbb6)

* If a cell output pin drives multiple fanout cells, the total capacitance on the output pin of the cell is the sum of all the input capacitances of the cells that it is driving plus the sum of the capacitance 
  of all the wire segments that comprise the net plus the output capacitance of the driving cell.
  
**Note :**
that in a CMOS cell, the inputs to the cell present a capacitive load only.

Figure below shows an example of a cell G1 driving three other cells G2, G3, and G4. Cs1, Cs2, Cs3 and Cs4 are the capacitance values of wire segments that comprise the net.

    Thus:
    Total cap (Output G1) = Cout(G1) + Cin(G2) + Cin(G3) + Cin(G4) + Cs1 + Cs2 + Cs3 + Cs4
    # Cout is the output pin capacitance of the cell.
    # Cin is the input pin capacitance of the cell.
    
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/27e2b7fe-abe5-41b4-871e-d92ccf1cc586)

This is the capacitance that needs to be charged or discharged when cell G1 switches and thus this total capacitance value impacts the timing of cell G1.

Thus,the max_capacitance limit set for a library cell in the .lib will inform the tool to reduce load on a particular node/net by using buffers,so that our cell performance/delay is not highly degraded.
This limit can be overriden by the user by providing custom max_capacitance limit through the use of constraints.

In below example, buffering has been done to reduce load capacitance on net at output of 1st AND Gate from right : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/af2ba1e4-ec42-4c0f-81e0-ca5cc07ff42f)


Delay Table Lookup : 

The delay table lookup method is a widely used technique in the characterization of standard cells in digital circuits. 
This method involves storing delay values in a table that can be accessed based on specific input conditions, such as input slew rates and output load capacitances. The delay values are typically measured during the characterization process and are stored in a lookup table (LUT) that can be used by logic synthesis and timing analysis tools to estimate the delays of the standard cells in a circuit.

The delay table lookup method is particularly useful for standard cells because it allows for the efficient representation of complex delay behavior. 
This is achieved by breaking down the delay into smaller components, each of which is a function of specific input conditions. 
The delay values are then stored in a table that can be accessed based on the input conditions, allowing for fast and accurate delay estimation during circuit simulation and timing analysis.

For corresponding output load and input transition we can get the cell delay values from the tables provided in the .lib files. index_1 represents the input transition ,index_2 represents the output load and the values represents the delay of the cell.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/e6ea9a42-0381-4591-97db-5a1b68fa389b)


In the following example, the delay value is interpolated from the values of delay for the nearest two table indices in two dimensions (the 4 values corresponding to the nearest values of Input Transition and Output Load from the table) :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/efe25618-d49b-46f1-aac6-d2432df102c2)

* Cell drive strength,area,pin attributes (such as clock:true or false,it should be true for clock pins of the cell,direction,functionality etc),Leakage power information,all timing information (rise & fall
  delays etc.), power information for different transitions (rise and fall) are part of the .lib file.

In the example shown below of `and2_1 & and2_2` cells,we can see as the drive strength of `and2_2` cell is more,it has lower delay for same input transition and output load.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/90738f67-fa83-4e43-9a23-e0128c606c3d)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/49102677-43b3-4c0f-9c24-bafd02501d5e)

Unateness : 

* Every cell has multiple timing arcs. For example, a combinational logic cell, such as and, or, nand, nor, adder cell, has timing arcs from each input to each output of the cell.
* Sequential cells such as flip-flops have timing arcs from the clock to the outputs and timing constraints for the data pins with respect to the clock.
* Each timing arc has a timing sense, that is, how the output changes for different types of transitions on input.This is called as `Unateness`.
* The timing arc is **positive unate** if a rising transition on an input causes the output to rise (or not to change) and a falling transition on an input causes the output to fall (or not to change). For 
  example, the timing arcs for and and or type cells are positive unate.
* A **negative unate** timing arc is one where a rising transition on an input causes the output to have a falling transition (or not to change) and a falling transition on an input causes the output to have a 
  rising transition (or not to change). For example, the timing arcs for nand and nor type cells are negative unate.
* In a **non-unate** timing arc, the output transition cannot be determined solely from the direction of change of an input but also depends upon the state of the other inputs. For example, the timing arcs in 
  an xor cell (exclusive-or) are non-unate.
* `Unateness` is important for timing as it specifies how the edges (transitions) can propagate through a cell and how they appear at the output of the cell.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f731c929-4d58-4d5d-b035-2e77c874f522)

**Note :** 

    In .lib file, for cells with **non_unate** timing sense (such as xor,xnor etc.), the pin information will have information for both postive unate and negative unate timing sense.

For Sequential cells like DFFs etc, 

* `CLK_N` is the clock pin of negedge flop.
* Clock-to-Q delay of flip-flop is mentioned as `timing_type : "falling_edge"` , informing that this is a negative edge flip-flop.
* Timing sense/unateness of Output Q is `non-unate` as `output Q` rises or falls according to rising or falling of `input D`.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/6be3c4de-d570-4c16-b002-67fa33bb26c5)

* Similarly,for a positive edge flip-flop, `CLK` is the clock pin of posedge flop.
* Clock-to-Q delay of flip-flop is mentioned as `timing_type : "rising_edge"` , informing that this is a negative edge flip-flop.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f4ba4880-c016-4b01-b472-a8f8bb00433f)

For setup check,the clock edge to be used is also mentioned as, `timing_type : "setup_falling";` or `timing_type : "setup_rising";` for negedge and posedge flop respectively.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/64bca089-6dd4-4619-83fb-a70fa0fdd6a8)

For Latches,
* For Negative Latch, setup check is done at sampling point which is **posedge of clock signal**,and this is mentioned in .lib as `timing_type : "setup_rising";`
* For Positive Latch, setup check is done at sampling point which is **negedge of clock signal**,and this is mentioned in .lib as `timing_type : "setup_falling";`

Left side is for Negative Latch and Right side of image is for Positive Latch : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/7230d16c-eb37-44d3-9f1d-faca3ade39ea)

#### Lab 2 - Querying Properties of .lib from dc_shell :

* `list_lib` - This command displays all libraries that are currently available in memory.
* `get_lib_cells */*and*` - This  command  creates a collection of library cells from the libraries currently loaded into memory that match the specified criteria. (pattern/regexp etc.)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/e711f27e-2633-495a-97ee-6aa87c89cb56)

* So,to print the value of the objects in collection,execute as shown below : 

        foreach_in_collection my_var [get_lib_cells */*and*] {                                                                                                                     
        set my_var_name [get_object_name $my_var]; echo $my_var_name;    # iterate over the collection and get the object name assigned to aparticular object and print it on the screen.                                                                                                            
        }

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/caf4cb1d-97e8-4999-b656-ae69e8dc6087)

* `get_lib_pins <cell_name>/*` - This  command  creates  a list  of library cell pins from the libraries currently loaded into memory that match the specified criteria.(cell_name or pattern etc.)
* `get_lib_attribute <lib_cell/lib_pin> <attribute_name>`- This  command  searches  object_list  for  the  specified attribute and returns a list of attribute values.  If the attribute is not  found  on any of 
                                                            the specified objects, the command returns an empty list.
  
* `get_lib_attribute <pin_name> direction` - Displays direction (input/output etc.)  of pin_name specified in command.

Following is a simple script to find pin direction of different pins of a library cell : 

    foreach_in_collection my_pins [get_lib_pins sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_0/*] {
    set my_pin_name [get_object_name $my_pins];
    set pin_dir [get_lib_attribute $my_pin_name direction];
    echo $my_pin_name $pin_dir;
    }

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/1eaecc22-ff4a-4920-bde5-ece1cfe76172)

* `get_lib_attribute sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_0/X function` - Displays functionality present at output pin X of and2 lib cell.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/df717d88-8460-400c-80d0-284f65a58337)

Screenshot of script to find pins of a nand4 cell and display function attribute of output pin Y : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/61f814eb-422f-4b35-ad07-446706779262)

* Script to take a list of 5 library cells, and print their output functionality :

        set lib_cell_list [list sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_1 \
        sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_2 \
        sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3_4 \
        sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_1 \
        sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_2 \
        sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand3b_4]
        
        set final_list ""
        
        # for each cell in the list find output pin name & its functionality
        #
        foreach my_cells $lib_cell_list {
        	foreach_in_collection my_lib_pin [get_lib_pins ${my_cells}/*] {
        		set my_lib_pin_name [get_object_name $my_lib_pin]
        		set pin_dir [get_lib_attribute $my_lib_pin_name direction]
        		if {$pin_dir == 2} {
        			set fn [get_lib_attribute $my_lib_pin_name function]
        			set val "$my_lib_pin_name\t$fn\t$pin_dir\n"
        			lappend final_list $val
        		}
        	}
        }
        
        puts "\n\nlib_cell_pin_name\tFunctionality\tPin_direction"
        
        foreach disp $final_list {
               echo $disp
        }

**Note : use source command to execute a .tcl script file in dc_shell**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/4f58414b-3c01-426a-b154-6879e37cf88c)

* `get_lib_attribute sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1 area` - Displays area of the specified cell according to the unit specified in .lib file.
* `get_lib_attribute sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/A capacitance` - Displays area of the specified cell according to the unit specified in .lib file.
* `get_lib_attribute sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__nand4_1/A clock` - checks whether specified pin is clock pin or not. displays true or false based on the fulfillment of mentioned condition.
* `get_lib_cells */* -filter "is_sequential == true" ` - filters all sequential cells from library and displays them on screen.
* `list_attributes -app` - list all the attributes which can be queried.

**Note : 
Attributes will be shown when it is queried on the object for which the object is defined.
For ex- area attribute can be queried for the library cell only not its' pins and capacitance attribute can be queried for library cell pins not for the library cell.**

* `list_attributes -app > a` # In dc_shell,this command will print all the attributes to a file `a` in present working directory.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a820d41a-8554-4f7d-b859-071811073fb8)



</details>

<details>

<summary>Day 8 - Advanced Constraints</summary>

#### Specifying Constraints Through SDC

To define a clock, we need to provide the following information:

1) Clock source: it can be a port of the design, or be a pin of a cell inside
   the design (typically that is part of a clock generation logic).
2) Period: the time period of the clock.
3) Duty cycle: the high duration (positive phase) and the low duration (negative phase).
4) Edge times: the times for the rising edge and the falling edge.

* By defining the clocks, all the internal timing paths (all flip-flop to flip-flop paths) are constrained; this implies that all internal paths can be analyzed with just the clock specifications. 
* The clock specification specifies that a flip-flop to flip-flop path must take one cycle.

**But is the above information enough?**

* In a real practical design, clock signal does not reach all the flops at the same time.
* Clock Network is built during Clock Tree Synthesis phase of Physical Implementation of a design.
* Before CTS,clock network is an ideal network and synthesis performs Logic Optimization based on the characteristics of this ideal network.
* To take into account the effects of **Clock Jitter** and **Clock Skew** , Clock uncertainty has to be defined through SDC before Synthesis is performed in design,so that no. of iterations to meet our timing 
  is reduced.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/cee70262-f611-4893-ab47-b1791c88150f)

**Clock Generation and Sources of JItter :**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/b5f24e27-0738-4ba6-8737-a9709da80008)

* Clock jitter refers to the deviation of a clock edge from its ideal position in time, which can be caused by factors like noise, power supply variations, or interference from nearby circuits.

**Clock Distribution and Clock Skew :**

* Clock skew refers to the difference in the arrival time of a clock signal at different components in a synchronous digital circuit system. It can occur due to various factors such as differences in 
  interconnect lengths, temperature variations, capacitive coupling, and material imperfections.

* Clock skew can be positive, where the receiving register gets the clock signal later than the transmitting register, or negative, where the transmitting register receives the clock signal later than the 
  receiving register.
* In digital circuit design, minimizing clock skew is crucial to ensure proper system operation, especially as clock rates increase, making timing more critical.
* Clock skew can impact the synchronization of digital circuits and is a key consideration in designing reliable and efficient systems.

* A clock distribution network is a crucial component in digital electronics responsible for distributing clock signals from a central source to various elements within a system that require synchronization.
  
* To minimize clock skew, complex synchronous circuits utilize clock distribution networks, also known as clock trees, which amplify and distribute the clock signal to ensure simultaneous arrival at all 
  register inputs. These networks are often automatically generated by electronic design automation (EDA) software based on key parameters like target frequency, register setup and hold time limits, and maximum 
  clock skew.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a34a81df-0591-46eb-b445-ec4d8669e602)

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/99cf372e-2852-46f0-bb7b-223cf817d56a)

  **Clock Modelling :**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/44b390af-ba07-4880-ac96-8a2d4c2c0c0b)

  **Constraints-Summary so far :**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/b857e0fc-1f93-440b-b9c3-52ba4bc00c9d)

  **How to constrain design in DC :**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/55459348-3767-4296-b786-62cc5735e03a)

  **Querying ports or Pins in the design :**

  **Note :** ports,pins,clock,etc. all names are case-sensitive in SDC format.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/56983831-83e9-4a27-908a-919ff7050c2a)

  **Querying clocks in the design :**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/fa69263d-be75-4d96-a52e-ff4bf1609753)

  **Querying Cells present in our design :**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/0a9342f3-050f-49fd-84a7-dd5b3565d479)

  **Defining Clocks :**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/71d22952-c657-4518-aa1d-e1fefd62c7ff)

  **Definiing Clock Latency and Clock Skew :**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/4437aa11-4ec3-4327-b8a1-742500089731)

  **Clock Waveform representation defined by create_clock constraint :**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/e0c128c3-cd88-4777-adde-38864bd014ce)

  **Constraining IO Paths :**

  For Input Paths :

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a58eb401-56df-4bb5-8c18-97d1fc70d7de)

  For Output Paths :

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/1d9e5dc2-fb1a-4c5c-96bd-3b27e19280fa)

#### Lab 1 - Loading design get_cells, get_ports, get_nets :

Synthesis of lab8_circuit.v :

RTL code of lab8_circuit.v :

    module lab8_circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk);
    reg REGA , REGB , REGC ; 
    
    always @ (posedge clk , posedge rst)
    begin
    	if(rst)
    	begin
    		REGA <= 1'b0;
    		REGB <= 1'b0;
    		REGC <= 1'b0;
    	end
    	else
    	begin
    		REGA <= IN_A | IN_B;
    		REGB <= IN_A ^ IN_B;
    		REGC <= !(REGA & REGB); 
    	end
    end
    
    assign OUT_Y = ~REGC;
    
    assign out_clk = clk;
    
    endmodule

Synthesis expectation according to RTL : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/af545e67-538d-4697-92a4-47860ed6b006)

In `/home/subhasis/Synthesis_labs/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP` use following commands to synthesize the design :

    csh
    dc_shell
    read_verilog verilog_files/lab8_circuit.v
    link # Performs  a  name-based resolution of design references for the current design.  For a design to be complete, it needs to be connected  to  all of  the  library  components and designs it references. 
           The references must be located and linked to the  current  design  in  order  for  the design  to be functional.  The purpose of this command is to locate all of the designs and library components 
           referenced in the current  design and connect (link) them to the current design.
           
    compile_ultra # The compile_ultra command performs a high-effort compile on the current design  for  better quality of results (QoR).  As with the compile command, optimization is controlled by constraints 
                    that we specify on the design.   This command is targeted toward high-performance designs with very tight timing constraints.  It provides us with a simple  approach to  achieve  critical  
                    delay  optimization.   The compile_ultra command packages all the DC Ultra features and enables  them  by  default.   It requires a DC Ultra license plus a DesignWare Foundation license.  
                    This command provides the best strategy for optimum overall QoR and  performance.

As we can see from screenshot below, 3 1-bit wide Flip-flops with Asyncronous reset have been inferred :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/4c267b43-dc7a-4a4a-96fe-d9cb5ecd0ac8)

Screenshot of execution of `get_ports` command : 

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/0c6d1880-6934-43c1-9491-fa37a2709beb)

Screenshot of execution of `get_cells` command :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/800f1277-5812-4f5c-a878-3cced9a57bb2)

`get_attribute [get_cells REGA_reg] ref_name` - To show the reference name (actual name of cell in .lib) on the screen

We can see REGA_reg cell instance has a reference name of `sky130_fd_sc_hd__dfrtp_1`. `sky130_fd_sc_hd__dfrtp_1` is a DFF with asyncronous reset,positive edge triggered with Q (true) as output.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f141a687-90b3-41d5-b75a-ba096828ac09)

Script to query reference name for all cells present in design :

    foreach_in_collection my_cells [get_cells *] {
    set my_cell_name [get_object_name $my_cells];
    set rname [get_attribute [get_cells $my_cell_name] ref_name];
    echo $my_cell_name $rname;
    }

`write -f ddc -out lab8_circuit.ddc` - write .ddc file to open in `design vision` tool.

Schematic of design as seen in design vision tool :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/46509041-4bff-46da-b46a-5b079f704fd6)

`get_nets *` - to display all the nets (Connection between two pins or between a pin and a port)

`all_connected N1` - to display all pins and ports connected to net N1.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3ae0b6bf-cf9e-47ba-966b-3547f1ea03de)

**Note : In digital design, Each and every net must have only one driver only.**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f2fe9de2-f969-4c65-8b61-ee2a62cde570)

Script to find which cells are driving and which are driven for a particular net in design : 

    foreach_in_collection  my_pins [all_connected n10] {
    set pin_name [get_object_name $my_pins];
    set dir [get_attribute [get_pins $pin_name] direction];
    echo $pin_name $dir;
    }

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/7c468a09-d749-48f5-9970-abe3fc0f21a3)

#### Lab 2 - get_pins, get_clocks, querying_clocks :

* `get_pins *` - Display all the pins (physical or hierarchical) in synthesized design.

Script to display all pins present in currently loaded design : 

    foreach_in_collection  my_pins [get_pins *] {
        set pin_name [get_object_name $my_pins];
        echo $pin_name;
        }

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/caeda74e-cbe9-4cef-8b69-bab2768b325f)

* `get_attribute [get_pins <pin_name>] direction` - Find direction of Pin (input,output,inout)
* `get_attribute [get_pins <pin_name>] clock` - checks whether the pin is a clock pin or not. (returns the value of true or false).

Script to display all pins which are clock pins in currently loaded design : 

    foreach_in_collection  my_pins [get_pins *] {
        set pin_name [get_object_name $my_pins];
        set pin_dir [get_attribute [get_pins $pin_name] direction]
        if { [regexp $pin_dir in] } {
        
        if {[get_attribute [get_pins $pin_name] clock] == true} {
        echo "$pin_name is a clock pin";
        }
        }
        }

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/8d8fb7bc-6813-4c37-83f1-56721e0254f0)

We can put above script in query_clock.tcl and source it in dc_shell, to achieve the same outcome :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/47f70140-ad26-49c1-a8e7-cc482644509a)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/f334f927-7c16-4337-9b5b-53bf3a5e207d)


* `get_attribute [get_pins <pin_name>] clocks` - Will tell which clocks/clock signal as defined by our SDC (create_clock) constraints are reaching the pin mentioned in the command.
* `get_clocks *` - Lists all clocks as defined by SDC (create_clock) for our design.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c635a85f-2391-456f-bde7-6b2a9e01f7df)

* We can see in below screenshot, as we have not defined any create_clock constraints, we are not getting any clock signal at CLK pin of the flop & no clocks are defined for the design.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/847aa19b-8113-4dd1-b14e-5242cdd7afdd)

#### Lab 3 - create_clock waveform :

* `current_design` - will tell the name of top module of currently loaded design in DC.
* `create_clock -name MYCLK -period 10 [get_ports clk]` - Define a clock MYCLK of period 10ns (100MHz) at the `clk` port of our design.
* `get_attribute [get_clocks MYCLK] period` - displays time period of clock MYCLK. (`units are as mentioned in .lib file`)
* `get_attribute [get_clocks MYCLK] is_generated` - displays if the clock is a generated clock or not.(true or false).
* `report_clocks *` - displays clock related information for all SDC defined clocks.

As we can see below, due to our definition of clock `MYCLK` using `create_clock` constraint, when we use the `get_attribute [get_pins REGA_reg/CLK] clocks` command, it reports that `MYCLK` clock is reaching the
CLK pin of the flop `REGA_reg`.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/98259828-d4bc-45a7-9b8e-654fd8095e49)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/ba4029aa-1c78-4d3c-aa40-aec1fd9d1631)

Modified Script to display all clock pins in the design and their associated SDC defined clock waveform :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/2de08434-a56c-4a34-aab9-14ba9c59ea3a)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/73322679-6d32-4fc2-b3fc-51666550bcde)

**Note :**

* **Although we can define the `create_clock` constraint for any port of the design, we should only define it for clock ports.**
* **Defining clock on any pin/port other than the clock port is meaningless and will lead to erroneous clock creation on non-clock ports and will hamper the implementation flow of the tool,and make the
    designers' task more difficult.**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3bae330c-132b-4669-ba26-611d3133804f)

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/b4d4d966-f6d4-451c-8326-17fb17979357)

* `remove_clock <list of clocks to be removed>` - remove the SDC defined clocks mentioned in clock list.


* `-waveform {1st_rise_edge 1st_fall_edge}` in `create_clock` constraint can be used to define our clock waveforms risng and falling edge,and hence cacn be used to define the duty cycle of the clock.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/e708c445-d242-49a3-a91f-9e01dd5fd40e)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/0f328409-721f-41e3-b410-f59e12c8af08)

Define clock with 25% duty cycle :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/61a683ee-3a02-469d-9671-0627f9b039e1)

#### Lab 4 - Clock Network Modelling - Uncertainty, report_timing :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d330e7b3-6418-484c-b510-bc6917771af1)

* `set_clock_latency -source 1 [get_clocks MYCLK]` - modelling clock source latency.
* `set_clock_latency 1 [get_clocks MYCLK]` - modelling clock netwrok latency.
* `set_clock_uncertainty 0.5 [get_clocks MYCLK]` - modelling clock uncertainty with respect to setup or max delay.
* `set_clock_uncertainty -hold 0.1 [get_clocks MYCLK]` - modelling clock uncertainty with respect to hold or min delay.
* `report_timing` - Provides a report of timing information for current design. By default,it reports the single worst setup path in each clock group.

**Note : If clocks are not defined, `report_timing` will show `paths are unconstrained.`**

Output of `report_timing` command :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a8ab8ab9-0e59-474f-8715-65e1f2b4adc1)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/5717e647-62a1-47f0-b866-340a833c692e)

Below is the explanation for subtracting clock uncertainty in required time calculation for setup analysis (because subtracting clock uncertainty in required time, it is worst case for setup) :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3028ca04-a55d-49aa-8ec2-980cc99d05fe)

Below is the explanation for adding clock uncertainty in required time calculation for hold analysis :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/fa9ccd0e-0296-4405-b1e0-d9fa06d56f2d)

`report_timing -delay_type min` - reports worst case hold path in each clock group.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d79b706d-3454-4f2d-af85-eaba62b0e3b0)

**Note :** 

* Setup generally is a single cycle check (launch and capture edges are different and separated by single clock period)

* Hold is a zero cycle check (launch and capture edge are same)

#### Lab 5 - Modelling IO delays :

`report_timing -from IN_A` - we can see as we have not applied IO delay constraints, it is reporting as path unconstrained from Input IN_A.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a4c7b442-b482-4641-9de9-074023cdd9c7)

`report_port -verbose` - Displays  information about ports of the current instance or the current design. `-verbose` option Specifies that the port report is to include all port information.
    
    report_port -verbose
     
    ****************************************
    Report : port
            -verbose
    Design : lab8_circuit
    Version: T-2022.03-SP5-6
    Date   : Wed May 22 00:20:48 2024
    ****************************************
    
    
                           Pin      Wire     Max     Max     Connection
    Port           Dir     Load     Load     Trans   Cap     Class      Attrs
    --------------------------------------------------------------------------------
    IN_A           in      0.0000   0.0000   --      --      --         
    IN_B           in      0.0000   0.0000   --      --      --         
    clk            in      0.0000   0.0000   --      --      --         
    rst            in      0.0000   0.0000   --      --      --         
    OUT_Y          out     0.0000   0.0000   --      --      --         
    out_clk        out     0.0000   0.0000   --      --      --         
    
    
                  External  Max             Min                Min       Min
                  Number    Wireload        Wireload           Pin       Wire
    Port          Points    Model           Model              Load      Load
    --------------------------------------------------------------------------------
    IN_A               1      --              --              --        -- 
    IN_B               1      --              --              --        -- 
    clk                1      --              --              --        -- 
    rst                1      --              --              --        -- 
    OUT_Y              1      --              --              --        -- 
    out_clk            1      --              --              --        -- 
    
                        Input Delay
                      Min             Max       Related   Max
    Input Port    Rise    Fall    Rise    Fall   Clock  Fanout
    --------------------------------------------------------------------------------
    IN_A          --      --      --      --      --      -- 
    IN_B          --      --      --      --      --      -- 
    clk           --      --      --      --      --      -- 
    rst           --      --      --      --      --      -- 
    
    
    
    
    --------------------------------------------------------------------------------
    
    
    
    
    
    
                   Max Tran        Min Tran
    Input Port    Rise    Fall    Rise    Fall
    --------------------------------------------------------------------------------
    IN_A          --      --      --      -- 
    IN_B          --      --      --      -- 
    clk           --      --      --      -- 
    rst           --      --      --      -- 
    
    
                        Output Delay
                      Min             Max      Related  Fanout
    Output Port   Rise    Fall    Rise    Fall  Clock     Load
    --------------------------------------------------------------------------------
    OUT_Y         --      --      --      --      --      0.00
    out_clk       --      --      --      --      --      0.00


* `set_input_delay -max 5 -clock [get_clocks MYCLK] [get_ports IN_A]` - model input delay for port IN_A
* `set_input_delay -max 5 -clock [get_clocks MYCLK] [get_ports IN_B]` - model input delay for port IN_B

* As we can see below,the input delay for the ports IN_A & IN_B are now applied.
        
        report_port -verbose
        Information: Updating design information... (UID-85)
         
        ****************************************
        Report : port
                -verbose
        Design : lab8_circuit
        Version: T-2022.03-SP5-6
        Date   : Wed May 22 00:27:01 2024
        ****************************************
        
        
                               Pin      Wire     Max     Max     Connection
        Port           Dir     Load     Load     Trans   Cap     Class      Attrs
        --------------------------------------------------------------------------------
        IN_A           in      0.0000   0.0000   --      --      --         
        IN_B           in      0.0000   0.0000   --      --      --         
        clk            in      0.0000   0.0000   --      --      --         
        rst            in      0.0000   0.0000   --      --      --         
        OUT_Y          out     0.0000   0.0000   --      --      --         
        out_clk        out     0.0000   0.0000   --      --      --         
        
        
                      External  Max             Min                Min       Min
                      Number    Wireload        Wireload           Pin       Wire
        Port          Points    Model           Model              Load      Load
        --------------------------------------------------------------------------------
        IN_A               1      --              --              --        -- 
        IN_B               1      --              --              --        -- 
        clk                1      --              --              --        -- 
        rst                1      --              --              --        -- 
        OUT_Y              1      --              --              --        -- 
        out_clk            1      --              --              --        -- 
        
                            Input Delay
                          Min             Max       Related   Max
        Input Port    Rise    Fall    Rise    Fall   Clock  Fanout
        --------------------------------------------------------------------------------
        IN_A          --      --      5.00    5.00  MYCLK     --    
        IN_B          --      --      5.00    5.00  MYCLK     --    
        clk           --      --      --      --      --      -- 
        rst           --      --      --      --      --      -- 
        
        
        
        
        --------------------------------------------------------------------------------
        
        
        
        
        
        
                       Max Tran        Min Tran
        Input Port    Rise    Fall    Rise    Fall
        --------------------------------------------------------------------------------
        IN_A          --      --      --      -- 
        IN_B          --      --      --      -- 
        clk           --      --      --      -- 
        rst           --      --      --      -- 
        
        
                            Output Delay
                          Min             Max      Related  Fanout
        Output Port   Rise    Fall    Rise    Fall  Clock     Load
        --------------------------------------------------------------------------------
        OUT_Y         --      --      --      --      --      0.00
        out_clk       --      --      --      --      --      0.00

`report_timing -from IN_A` is not showing path is unconstrained now. It is showing the setup path analysis for IN_A startpoint paths.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/845309ca-7659-4ac8-b57a-f57d58f4744c)

`report_timing -from IN_A -trans -net -cap -nosplit > a` - report timing information alongwith transition and capacitance info and store in file `a`.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c0b6b680-064e-4939-bbe3-1d6eebdd2ccd)

`report_timing -from IN_A -trans -net -cap -nosplit -delay_type min` shows path is unconstrained because we have still not modelled input delay for IN_A for min values.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9d457724-916e-472c-8fa5-98c293344b28)

* `set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_A]` - model input delay for port IN_A for min delay.
* `set_input_delay -min 1 -clock [get_clocks MYCLK] [get_ports IN_B]` - model input delay for port IN_B for min delay.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/beff04b0-480a-459c-93a8-cc92eb684308)


* `set_input_transition -max 0.3 [get_ports IN_A]` - model max input transition for port IN_A.
* `set_input_transition -min 0.1 [get_ports IN_A]` - model min input transition for port IN_A.
* `set_input_transition -max 0.3 [get_ports IN_B]` - model max input transition for port IN_B.
* `set_input_transition -min 0.1 [get_ports IN_B]` - model min input transition for port IN_B.
* `set_output_delay -max 5 -clock [get_clocks MYCLK] [get_ports OUT_Y]` - model max output delay for output port OUT_Y.
* `set_output_delay -min 1 -clock [get_clocks MYCLK] [get_ports OUT_Y]` - model min output delay for output port OUT_Y.
* `set_load -max 0.4 [get_ports OUT_Y]` - model max output load for output port OUT_Y.
* `set_load -min 0.1 [get_ports OUT_Y]` - model min output load for output port OUT_Y.


* We can see all the values of input delay,input transition,output delay,output load we have specified have been applied for the design.
  
            report_port -verbose
            Information: Updating design information... (UID-85)
             
            ****************************************
            Report : port
                    -verbose
            Design : lab8_circuit
            Version: T-2022.03-SP5-6
            Date   : Wed May 22 00:46:51 2024
            ****************************************
            
            
                                   Pin      Wire     Max     Max     Connection
            Port           Dir     Load     Load     Trans   Cap     Class      Attrs
            --------------------------------------------------------------------------------
            IN_A           in      0.0000   0.0000   --      --      --         
            IN_B           in      0.0000   0.0000   --      --      --         
            clk            in      0.0000   0.0000   --      --      --         
            rst            in      0.0000   0.0000   --      --      --         
            OUT_Y          out     0.4000   0.0000   --      --      --         
            out_clk        out     0.0000   0.0000   --      --      --         
            
            
                          External  Max             Min                Min       Min
                          Number    Wireload        Wireload           Pin       Wire
            Port          Points    Model           Model              Load      Load
            --------------------------------------------------------------------------------
            IN_A               1      --              --              --        -- 
            IN_B               1      --              --              --        -- 
            clk                1      --              --              --        -- 
            rst                1      --              --              --        -- 
            OUT_Y              1      --              --              0.1000    -- 
            out_clk            1      --              --              --        -- 
            
                                Input Delay
                              Min             Max       Related   Max
            Input Port    Rise    Fall    Rise    Fall   Clock  Fanout
            --------------------------------------------------------------------------------
            IN_A          1.00    1.00    5.00    5.00  MYCLK     --    
            IN_B          1.00    1.00    5.00    5.00  MYCLK     --    
            clk           --      --      --      --      --      -- 
            rst           --      --      --      --      --      -- 
            
            
            
            
            --------------------------------------------------------------------------------
        
        
        
        
        
        
                       Max Tran        Min Tran
        Input Port    Rise    Fall    Rise    Fall
        --------------------------------------------------------------------------------
        IN_A          0.30    0.30    0.10    0.10
        IN_B          0.30    0.30    0.10    0.10
        clk           --      --      --      -- 
        rst           --      --      --      -- 
        
        
                            Output Delay
                          Min             Max      Related  Fanout
        Output Port   Rise    Fall    Rise    Fall  Clock     Load
        --------------------------------------------------------------------------------
        OUT_Y         1.00    1.00    5.00    5.00  MYCLK     0.00  
        out_clk       --      --      --      --      --      0.00




#### Generated Clocks :

* Generated clocks are a crucial aspect of digital design, particularly in the context of field-programmable gate arrays (FPGAs) and other digital systems. They refer to clocks that are not directly connected 
  to the primary clock source but are instead derived from it through various means, such as logic circuits, counters, or flip-flop dividers.
* There are two primary types of generated clocks: those automatically derived by the design tools and user-defined generated clocks.
* The importance of generated clocks lies in their ability to provide flexibility in clocking different parts of a digital system. While it is theoretically possible to design a system with only a master clock, 
  using generated clocks offers several advantages.
  
* Generated clocks allow for the creation of clock domains with different frequencies, phases, or edges, which can be essential for various applications. 
* For instance, a system might require a slower clock for a specific module or a clock with a particular phase relationship to the master clock. Generated clocks make it possible to create these custom clock 
  domains without the need for additional external clock sources.
* The process of creating generated clock constraints involves defining the relationship between the generated clock and the master clock. This can be done using directives such as `create_generated_clock`.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/388f03ab-7650-401c-9dde-abfc9e9812b3)

**Note : Generated Clocks are always created with respected to master clocks (Clocks at clock sources (Internal PLL,oscillator etc.) or primary Clock port of design (external clock sources)).**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d9035ef2-5e9e-4ea6-aede-8d747f222c87)

**Constraining Designs with generated clocks :**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/5bfed5df-5e60-4c29-b360-bb46631daac5)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/19c6fd2e-214f-4ea1-8356-8576fa9e5a6b)



#### Lab 6 - Modelling Generated Clocks :

Modelling relationship between input clock `MYCLK` and `out_clk` :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/e7d0487b-b50a-4e28-832f-4c902fb21ea0)

`report_timing -to OUT_Y` without generated clock specification :

    report_timing -to OUT_Y
     
    ****************************************
    Report : timing
            -path full
            -delay max
            -max_paths 1
    Design : lab8_circuit
    Version: T-2022.03-SP5-6
    Date   : Wed May 22 01:00:29 2024
    ****************************************
    
    Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
    Wire Load Model Mode: top
    
      Startpoint: REGC_reg (rising edge-triggered flip-flop clocked by MYCLK)
      Endpoint: OUT_Y (output port clocked by MYCLK)
      Path Group: MYCLK
      Path Type: max
    
      Point                                        Incr       Path
      ---------------------------------------------------------------
      clock MYCLK (rise edge)                      0.00       0.00
      clock network delay (ideal)                  2.00       2.00
      REGC_reg/CLK (sky130_fd_sc_hd__dfrtp_1)      0.00       2.00 r
      REGC_reg/Q (sky130_fd_sc_hd__dfrtp_1)        0.30       2.30 r
      U10/Y (sky130_fd_sc_hd__clkinv_1)            2.32       4.62 f
      OUT_Y (out)                                  0.00       4.62 f
      data arrival time                                       4.62
    
      clock MYCLK (rise edge)                     10.00      10.00
      clock network delay (ideal)                  2.00      12.00
      clock uncertainty                           -0.50      11.50
      output external delay                       -5.00       6.50
      data required time                                      6.50
      ---------------------------------------------------------------
      data required time                                      6.50
      data arrival time                                      -4.62
      ---------------------------------------------------------------
      slack (MET)                                             1.88

* Clock Divide-by-2 :

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/caab8c0e-e04e-46da-b118-20b8b3f2b6d2)


* `create_generated_clock -name MYGEN_CLK -master MYCLK -source [get_ports clk] -div 1 [get_ports out_clk]` - deifning a generated clock MYGEN_CLK with master clock as MYCLK to model the differences between 
                                                                                                              `clk` & `out_clk`, as `out_clk` will have some delay(routing delay/Time of Flight) when coming from 
                                                                                                              `clk` input.

* Output of report_clocks command :
  
        report_clocks *
        Information: Updating graph... (UID-83)
         
        ****************************************
        Report : clocks
        Design : lab8_circuit
        Version: T-2022.03-SP5-6
        Date   : Wed May 22 01:09:00 2024
        ****************************************
        
        Attributes:
            d - dont_touch_network
            f - fix_hold
            p - propagated_clock
            G - generated_clock
            g - lib_generated_clock
        
        Clock          Period   Waveform            Attrs     Sources
        --------------------------------------------------------------------------------
        MYCLK           10.00   {0 5}                         {clk}
        MYGEN_CLK       10.00   {0 5}               G         {out_clk}
        --------------------------------------------------------------------------------
        
        Generated     Master         Generated      Master         Waveform
        Clock         Source         Source         Clock          Modification
        --------------------------------------------------------------------------------
        MYGEN_CLK     clk            {out_clk}      MYCLK          divide_by(1)
        --------------------------------------------------------------------------------


`set_clock_latency -max 1 [get_clocks MYGEN_CLK]` - to specify clock latency for MYGEN_CLK.
`set_output_delay -max 5 [get_ports OUT_Y] -clock [get_clocks MYGEN_CLK]` - Annotating max output delay for OUT_y with repsect to generated clock MYGEN_CLK.
`set_output_delay -min 1 [get_ports OUT_Y] -clock [get_clocks MYGEN_CLK]` - Annotating min output delay for OUT_y with repsect to generated clock MYGEN_CLK.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/7c23aa24-fef7-403a-a5a2-b0c0afa8a9bf)

Let us 1st `reset_design` and read new design lab8_circuit_modified.v.

* `lab8_circuit_modified.v` :
    
        module lab8_circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk , output reg out_div_clk);
        reg REGA , REGB , REGC ; 
        
        always @ (posedge clk , posedge rst)
        begin
        	if(rst)
        	begin
        		REGA <= 1'b0;
        		REGB <= 1'b0;
        		REGC <= 1'b0;
        		out_div_clk <= 1'b0;
        	end
        	else
        	begin
        		REGA <= IN_A | IN_B;
        		REGB <= IN_A ^ IN_B;
        		REGC <= !(REGA & REGB);
        		out_div_clk <= ~out_div_clk; 
        	end
        end
        
        assign OUT_Y = ~REGC;
        
        assign out_clk = clk;
        
        endmodule

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/99a452d7-716f-4faf-b527-451262fa3530)

* As we have `reset_design` and the loaded new design file `lab8_circuit_modified.v`, all our previously applied constraints are now erased from memory.
* So we can now create a `lab8_cons.tcl` file to store our constraints,so that it can be easily sourced & constraints can be re-applied when we reset the design.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/8d7a6244-2636-47d1-85f5-06776fccca0b)

* After linking the design with `link` command. we can apply our constraint by `source lab8_cons.tcl` command.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/93d27bea-457a-44d5-bfa4-f0aa84672de7)

* `get_generated_clocks` - this command displays the generated clocks defined for our design.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/050f7748-1ffb-463a-b18a-36e872e29bda)

* We can see all information related to ports using `report_ports -verbose` command :

          report_port -verbose
        Information: Updating design information... (UID-85)
         
        ****************************************
        Report : port
                -verbose
        Design : lab8_circuit
        Version: T-2022.03-SP5-6
        Date   : Wed May 22 01:32:27 2024
        ****************************************
        
        
        
        Attributes:
            c - port_is_clock_port
        
                               Pin      Wire     Max     Max     Connection
        Port           Dir     Load     Load     Trans   Cap     Class      Attrs
        --------------------------------------------------------------------------------
        IN_A           in      0.0000   0.0000   --      --      --         
        IN_B           in      0.0000   0.0000   --      --      --         
        clk            in      0.0000   0.0000   --      --      --         
        rst            in      0.0000   0.0000   --      --      --         
        OUT_Y          out     0.4000   0.0000   --      --      --         
        out_clk        out     0.0000   0.0000   --      --      --         c
        out_div_clk    out     0.0000   0.0000   --      --      --         c
        
        
                      External  Max             Min                Min       Min
                      Number    Wireload        Wireload           Pin       Wire
        Port          Points    Model           Model              Load      Load
        --------------------------------------------------------------------------------
        IN_A               1      --              --              --        -- 
        IN_B               1      --              --              --        -- 
        clk                1      --              --              --        -- 
        rst                1      --              --              --        -- 
        OUT_Y              1      --              --              0.1000    -- 
        out_clk            1      --              --              --        -- 
        out_div_clk        1      --              --              --        -- 
        
                            Input Delay
                          Min             Max       Related   Max
        Input Port    Rise    Fall    Rise    Fall   Clock  Fanout
        --------------------------------------------------------------------------------
        IN_A          1.00    1.00    5.00    5.00  MYCLK     --    
        IN_B          1.00    1.00    5.00    5.00  MYCLK     --    
        clk           --      --      --      --      --      -- 
        rst           --      --      --      --      --      -- 
        
        
        
        
        --------------------------------------------------------------------------------
        
        
        
        
        
        
                       Max Tran        Min Tran
        Input Port    Rise    Fall    Rise    Fall
        --------------------------------------------------------------------------------
        IN_A          0.40    0.40    0.10    0.10
        IN_B          0.40    0.40    0.10    0.10
        clk           --      --      --      -- 
        rst           --      --      --      -- 
        
        
                            Output Delay
                          Min             Max      Related  Fanout
        Output Port   Rise    Fall    Rise    Fall  Clock     Load
        --------------------------------------------------------------------------------
        OUT_Y         1.00    1.00    5.00    5.00  MYGEN_CLK
                                                              0.00  
        out_clk       --      --      --      --      --      0.00
        out_div_clk   --      --      --      --      --      0.00


**Status of Design, so far :**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/e284fabb-9efd-4ca2-9bfc-d5af07f6e021)


  


#### Input Delay and Output Delay Constraints :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d7526f19-f285-426f-8b98-c9c970a0e7a6)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/fa3e76c3-eed0-433d-be22-25d951b59225)

#### Constraining Purely combinationational path from input to output using set_max_latency constraint :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/578e79fe-490e-4161-ac22-3f8957ada323)

#### Constraining Purely combinationational path from input to output using virtual clocks :

* A **virtual clock** is a clock that exists but is not associated with any pin or port of the design. It is used as a **reference in STA analysis to specify input and output delays relative to a clock.**

 ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9a8b4447-295b-4162-b231-a2a69d0d1557)


#### Constraining IO paths originating with respect to both rising and falling edge of clock :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/6a9ccfff-8f47-4fa8-9f4a-ebe6d87b2053)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/022aa207-9e45-4298-b3f7-e3c4c1ccaec8)

#### Constraining Input Transition with set_driving_cell constraint instead of set_input_transition :

* The set_driving_cell specification offers a more convenient and accurate approach in describing the drive capability of a port. The set_driving_cell can be used to specify a cell driving an input port.
* set_driving_cell constraint can be used to more accurately model input transition value,and is recommended for internal module IOs instead of set_input_transition constraint.
* set_input_transition is recommended for Primary IOs of design connected to external world,where the transition is known/modelled based on standard interface specifications.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/0c3e65a9-4e40-4241-8c98-5da9e6f43002)

#### Lab 7 - Modelling purely combinational path with set_max_delay constraint :

lab14_circuit.v RTL (Design to undergo Synthesis) :

    module lab8_circuit (input rst, input clk , input IN_A , input IN_B , output OUT_Y , output out_clk , output reg out_div_clk , input IN_C , input IN_D , output OUT_Z );
    reg REGA , REGB , REGC ; 
    
    always @ (posedge clk , posedge rst)
    begin
    	if(rst)
    	begin
    		REGA <= 1'b0;
    		REGB <= 1'b0;
    		REGC <= 1'b0;
    		out_div_clk <= 1'b0;
    	end
    	else
    	begin
    		REGA <= IN_A | IN_B;
    		REGB <= IN_A ^ IN_B;
    		REGC <= !(REGA & REGB);
    		out_div_clk <= ~out_div_clk; 
    	end
    end
    
    assign OUT_Y = ~REGC;
    
    assign out_clk = clk;
    assign OUT_Z = IN_C ^ IN_D ;
    
    
    endmodule

 ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a59ed71e-a6b3-429c-b6a8-2d60fa9cd009)

 `source lab8cons.tcl` - to apply the already available constraint, because current_design `(lab14_circuit.v)` is only slightly different from previously used design `(lab8_circuit_modified.v)`.

* Here, we can see, as we have not constrained the path starting from `input IN_C` & ending at `output OUT_Z`, tool is reporting that path as unconstrained.
* These type of input to output paths (purely combinational) can be constrained with `set_max_latency` constraint.

 ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9c5f5ebc-87e5-4e51-86fc-86f11f7187ce)

 ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/bfdf9730-3347-4bb7-9471-bde6d829b93e)


* `all_inputs` - reports all input ports as a collection.
* `all_outputs` - reports all output ports as a collection.
* `all_registers` - reports all registers present in design as a collection.
* `all_clocks` - reports all clocks defined (master & generated) in the design as a collection.
* `all_registers -clock <clock_name>` - reports all registers driven by specified clock as a collection.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/5c37bda0-4447-4aba-99e5-4c8fd066c3ab)

**Note :**

* **`MYGEN_CLK` & `MYGEN_DIV_CLK` are clocks coming out of the design and are not driving any registers in the design.**




`all_fanout` - The all_fanout command reports the timing fanout  of  specified  source pins,  ports,  or nets in the design.  A pin is considered to be in the timing fanout of a sink if there is a timing path 
               through combinational logic  from  that  source  to  the pin.  The fanout report stops at the inputs to registers (sequential cells).  The source pins or  ports  are specified by using the
               -clock_tree or -from source_list option.

`all_fanout -from IN_A -flat` - reports all fanout pins from input IN_A
`all_fanout -from IN_A -flat -endpoints_only` - reports all fanout pins ending at a timing endpoint only.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a8f1908d-5b89-4771-88bf-6a5b280f81ee)

Script to report all fanout cells connected to a startpoint :

    foreach_in_collection my_fanouts [all_fanout -from IN_A] {
      set my_fanout_pnt_name [get_object_name $my_fanouts]
      if { regexp $my_fanout_pnt_name IN_A } {
          continue
      } else {
           set my_cell_name [get_attribute [get_cells -of_objects [get_pins $my_fanout_pnt_name]] ref_name];
           echo "$my_cell_name\t$my_fanout_pnt_name
        }
    }   
    

* `get_cells -of_objects [get_pins <pin_name>]` - returns the cell name for the specified pin mentioned.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/169c5f79-510a-4a26-a46b-5de7d51e4e86)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/046b3890-28c9-45c6-b5d4-8d8df19f180f)


* `all_fanin -to REGA_reg/D -flat` - reports all fanin pins at REGA_reg/D pin.
* `all_fanin -to REGA_reg/D -flat -startpoints_only` - reports all fanin pins starting at a timing startpoint only.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3803202b-bbc4-4715-8d96-9f6baab8566c)

* We are trying to constrain the purely combinational path between `IN_C & IN_D` and `OUT_Z` :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/301f542a-8436-474f-9a85-6f61c57a90df)


* **`set_max_delay 0.1 -from [all_inputs] -to [get_ports OUT_Z]` - applying max latency(delay) of 0.1ns from all input ports to output port OUT_Z.**
* **Note : The above constraint will only be applied between combinational path between `IN_C & IN_D` and `OUT_Z` as no other paths between any other input & `OUT_Z` exists.**

* Upon applying the constraint and using `report_timing -to OUT_Z` command to analyze paths to `OUT_Z` we can see that the path is failing setup time requirement.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9d0ef6f7-d147-47e6-898b-8e83b1cb42d4)

* As earlier we had not specified the `set_max_delay` constraint, DC tool has not optimized the purely combinational path between `IN_C & IN_D` and `OUT_Z`.
* Hence, now we can rerun `compile_ultra` command, so all constraints are taken into consideration for optimizing the design.
* Upon reviewing timng paths to `OUT_Z` using `report_timing -to OUT_Z` we observe that we are now meeting our setup time requirement,while the `set_max_delay` constraint is taken into consideration.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/93e9c3e6-68a5-4512-a3f1-c6c793847281)

#### Lab 8 - Modelling delays using virtual clock :

* A virtual clock is a clock that exists but is not associated with any pin or port of the design. It is used as a reference in STA analysis to specify input and output delays relative to a clock. 
* An example where virtual clock is applicable is shown in Figure below . 
* The design under analysis gets its clock from CLK_CORE, but the clock driving input port ROW_IN is CLK_SAD.How does one specify the IO constraint on input port ROW_IN in such cases?
* The same issue occurs on the output port STATE_O.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a87dd42c-57fa-4160-9662-f17ed7a18175)

* To handle such cases, a virtual clock can be defined with no specification of the source port or pin. In the example given above, the virtual clock is defined for CLK_SAD and CLK_CFG.
* `create_clock -name VIRTUAL_CLK_SAD -period 10 -waveform {2 8}` - Defining the virtual clock.
* `create_clock -name VIRTUAL_CLK_CFG -period 8 -waveform {0 4}`
* `create_clock -period 10 [get_ports CLK_CORE]` - real clock of design under analysis.

* Having defined these virtual clocks, the IO constraints can be specified relative to this virtual clock.
  
    `set_input_delay -clock VIRTUAL_CLK_SAD -max 2.7 [get_ports ROW_IN]`
    `set_output_delay -clock VIRTUAL_CLK_CFG -max 4.5 [get_ports STATE_O]`


* Figure below shows the timing relationships on the input path. This constrains the input path in the design under analysis to be 5.3ns or less.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/62140976-eb64-41f9-a64d-cdca3d055e4a)


* Figure below shows the timing relationships on the output path. This constrains the output path in the design under analysis to be 3.5ns or less.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/80403908-a70a-4ba6-aa53-2cf907d93578)

* **Now returning to the task of defining a virtual clock MYVCLK for the design given below,and model the IO delays w.r.t the MYVCLK virtual clock.**

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/9373db49-e2da-4e98-8023-31c89d144342)

* We should run following commands to synthesis=ze the design without modelling IO delays for purely combinational path between `IN_C & IN_D` & `OUT_Z` :
    * `reset_design`
    * `read_verilog verilog_files/lab14_circuit.v`
    * `source lab8_cons.tcl`
    * `link`
    * `compile_ultra`

We can observe the **paths to `OUT_Z` remain unconstrained** :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/0d43df1a-2410-4e34-8308-ba1e5f920faf)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/48749b56-e394-4d5d-a8de-c5d7e130ec0c)


* `create_clock -name MYVCLK -period 10` - creating virtual clock `MYVCLK` with period of 10ns.

**We can see the virtual clock `MYVCLK` is defined with no source** :

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d6217f2b-7058-4756-af7c-6dcb0c1651c5)

Here,we have defined input delay and output delay for ports `IN_C,IN_D & OUT_Z` respectively, such that only 0.1ns/100ps of delay/time only is avalaible for the Combo Logic.

* `set_input_delay -max 5 [get_ports IN_C] -clock [get_clocks MYVCLK]` - annotating 5ns input delay for port IN_C w.r.t virtual clock MYVCLK.
* `set_input_delay -max 5 [get_ports IN_D] -clock [get_clocks MYVCLK]` - annotating 5ns input delay for port IN_D w.r.t virtual clock MYVCLK.
* `set_input_delay -max 4.9 [get_ports OUT_Z] -clock [get_clocks MYVCLK]` - annotating 5ns input delay for port IN_C w.r.t virtual clock MYVCLK.

Here,we can see our required paths are constrained and getting max path violation :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/6af82226-b785-4d59-939d-df4d49633976)

* Upon rerunning `compile_ultra` command to resynthesize the design,incorporating newly given constraints to its implementation and optimization flow, we observe our required paths are getting optimized in the
  same way if we would have defined these input and output delays by using `set_max_delay` command instead of using `virtual clock` concept.

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/3b2bc65c-3f0f-48ad-b848-4d8d3a13b128)


* `report_port -verbose` command shows that the input and output delays we had defined with respect to virtual clock `MYVCLK` have been properly applied.
  
        ****************************************
        Report : port
                -verbose
        Design : lab8_circuit
        Version: T-2022.03-SP5-6
        Date   : Wed May 22 16:56:59 2024
        ****************************************
        
        
        
        Attributes:
            c - port_is_clock_port
        
                               Pin      Wire     Max     Max     Connection
        Port           Dir     Load     Load     Trans   Cap     Class      Attrs
        --------------------------------------------------------------------------------
        IN_A           in      0.0000   0.0000   --      --      --         
        IN_B           in      0.0000   0.0000   --      --      --         
        IN_C           in      0.0000   0.0000   --      --      --         
        IN_D           in      0.0000   0.0000   --      --      --         
        clk            in      0.0000   0.0000   --      --      --         
        rst            in      0.0000   0.0000   --      --      --         
        OUT_Y          out     0.4000   0.0000   --      --      --         
        OUT_Z          out     0.0000   0.0000   --      --      --         
        out_clk        out     0.0000   0.0000   --      --      --         c
        out_div_clk    out     0.0000   0.0000   --      --      --         c
        
        
                      External  Max             Min                Min       Min
                      Number    Wireload        Wireload           Pin       Wire
        Port          Points    Model           Model              Load      Load
        --------------------------------------------------------------------------------
        IN_A               1      --              --              --        -- 
        IN_B               1      --              --              --        -- 
        IN_C               1      --              --              --        -- 
        IN_D               1      --              --              --        -- 
        clk                1      --              --              --        -- 
        rst                1      --              --              --        -- 
        OUT_Y              1      --              --              0.1000    -- 
        OUT_Z              1      --              --              --        -- 
        out_clk            1      --              --              --        -- 
        out_div_clk        1      --              --              --        -- 
        
                            Input Delay
                          Min             Max       Related   Max
        Input Port    Rise    Fall    Rise    Fall   Clock  Fanout
        --------------------------------------------------------------------------------
        IN_A          1.00    1.00    5.00    5.00  MYCLK     --    
        IN_B          1.00    1.00    5.00    5.00  MYCLK     --    
        IN_C          --      --      5.00    5.00  MYVCLK    --    
        IN_D          --      --      5.00    5.00  MYVCLK    --    
        clk           --      --      --      --      --      -- 
        rst           --      --      --      --      --      -- 
        
        
                       Max Drive      Min Drive      Resistance    Min    Min       Cell
        Input Port    Rise    Fall   Rise    Fall   Max     Min    Cap    Fanout    Deg
        --------------------------------------------------------------------------------
        IN_A          --      --     --      --     --      --     --     --        -- 
        IN_B          --      --     --      --     --      --     --     --        -- 
        IN_C          --      --     --      --     --      --     --     --        -- 
        IN_D          --      --     --      --     --      --     --     --        -- 
        clk           --      --     --      --     --      --     --     --        -- 
        rst           --      --     --      --     --      --     --     --        -- 
        
        
                       Max Tran        Min Tran
        Input Port    Rise    Fall    Rise    Fall
        --------------------------------------------------------------------------------
        IN_A          0.40    0.40    0.10    0.10
        IN_B          0.40    0.40    0.10    0.10
        IN_C          --      --      --      -- 
        IN_D          --      --      --      -- 
        clk           --      --      --      -- 
        rst           --      --      --      -- 
        
        
                            Output Delay
                          Min             Max      Related  Fanout
        Output Port   Rise    Fall    Rise    Fall  Clock     Load
        --------------------------------------------------------------------------------
        OUT_Y         1.00    1.00    5.00    5.00  MYGEN_CLK
                                                              0.00  
        OUT_Z         --      --      4.90    4.90  MYVCLK    0.00  
        out_clk       --      --      --      --      --      0.00
        out_div_clk   --      --      --      --      --      0.00



</details>

<details>

<summary>Day 9 - Introduction to BabySoC Modelling</summary>

#### What is a SoC and Why SoC should be used ? :

A System on a Chip (SoC) is an integrated circuit that consolidates all the necessary components of a computer or other electronic system onto a single chip. These components typically include:

1) Central Processing Unit (CPU): The primary processor responsible for executing instructions and managing tasks.
2) Memory: Such as RAM and ROM, for temporary and permanent data storage.
3) Input/Output (I/O) Ports: Interfaces for communication with other devices and peripherals.
4) Graphics Processing Unit (GPU): Handles rendering of images and video.
5) Digital Signal Processor (DSP): Specializes in handling audio and video processing.
6) Other specialized modules: These can include wireless communication components (e.g., Wi-Fi, Bluetooth), power management circuits, and sensors.

**Key Advantages of SoCs :**
1) Size Reduction: Integrating multiple components into a single chip significantly reduces the overall size  of the device.
2) Power Efficiency: SoCs typically consume less power than systems with discrete components because of optimized interconnections and reduced need for external interfaces.
3) Performance: Close proximity of components can lead to faster data transfer rates and improved overall performance.
4) Cost Efficiency: Manufacturing a single chip can be more cost-effective than producing multiple separate components, leading to lower production costs for the end devices.
5) Reliability: Fewer interconnections between separate components reduce the likelihood of failure due to connection issues.

**Common Applications of SoCs :** 
1) Smartphones and Tablets: SoCs are fundamental in mobile devices due to their compact size and efficiency.
2) Wearable Devices: Such as smartwatches and fitness trackers, which require compact and power-efficient processing.
3) IoT Devices: Internet of Things (IoT) devices often use SoCs to handle various sensors and connectivity tasks.
4) Embedded Systems: Used in automotive, industrial, and consumer electronics for dedicated processing tasks.

**Examples of Popular SoCs :**
1) Apple A-Series: Used in iPhones and iPads.
2) Qualcomm Snapdragon: Found in many Android smartphones.
3) Samsung Exynos: Used in Samsung devices.
4) NVIDIA Tegra: Used in devices like the Nintendo Switch.

**Challenges and Considerations :**
1) Design Complexity: Integrating multiple functions onto a single chip is complex and requires sophisticated design and manufacturing processes.
2) Heat Management: Concentrating multiple components in a small area can lead to heat dissipation issues, which need to be managed effectively.
3) Flexibility: SoCs are less flexible than discrete systems because they are highly integrated and customized for specific applications.

Overall, SoCs play a crucial role in modern electronics by enabling more compact, efficient, and powerful devices.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/7b1fde18-2540-44fb-ac09-bccf9182b6d5)


#### Types of SoC :

• SoCs built around a microcontroller
• SoCs built around a microprocessor, often found in cell phones
• Specialized application-specific integrated circuit SoCs designed for specific applications that do 
  not fit into the above two categories

#### SoC Structure :

• An SoC consists of hardware functional units, including microprocessors that run software code, 
  as well as a communications subsystem to connect, control, direct and interface between these 
  functional modules.
• Functional components: Processor Cores, Memory, Interfaces, Digital Signal Processor, others
• Intermodule communication: Bus-Based Communication, Network on a chip.


#### SoC Design Flow :

SoC development process can be broken into multiple stages as illustrated in the following figure:

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/83388ec1-e301-41c5-b7fe-56822f260a52)

#### Introduction to VSDBabySoC :

VSDBabySoC is a small yet powerful RISCV-based SoC. The main purpose of designing such a small SoC is to test three open-source IP cores together for the first time and calibrate the analog part of it. VSDBabySoC contains one RVMYTH microprocessor, an 8x-PLL to generate a stable clock, and a 10-bit DAC to communicate with other analog devices.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/04238eab-4d48-4d57-9061-f8b660a83d6e)

#### BabySoC Components :

* RVMYTH: RVMYTH core is a simple RISC V-based CPU.
* PLL: A phase-locked loop or PLL is a control system that generates an output signal whose phase is related to the phase of an input signal. PLLs are widely used for synchronization purposes, including clock 
       generation and distribution.
* DAC: A digital-to-analog converter or DAC is a system that converts a digital signal into an analog signal. DACs are widely used in modern communication systems enabling the generation of digitally-defined 
       transmission signals.


#### What is a PLL ?

* A phase-locked loop (also phase lock loop or PLL) is a system that generates an output signal whose phase is related to its input. The two signals will have the same frequency and either no phase difference 
  or a constant phase difference between them.

 * A PLL typically consists of a phase detector, a loop filter, and a voltage-controlled oscillator (VCO).
 * The phase detector compares the reference signal with the oscillator frequency and outputs an error 
   signal.
 * The loop filter (usually a low-pass filter) then generates an error voltage from the error signal.
 *  The VCO then increases or decreases the oscillator frequency to lock to the input frequency. This produces an output frequency that is equal to the input frequency, and a constant phase shift (which could 
    be zero) between the two signals.
 *  A PLL may also have a frequency divider in its feedback loop in order to create an output that is a multiple of the reference frequency instead of one that is exactly equal to it.

   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/fd7730e9-a867-4ce3-bfc6-9453e3d8ad14)

##### Why off-chip clocks can’t be used all the time?

* The clock will be a supply for a lot of blocks on the chip, it will have delays due to long wires(if used only one clock source) - also reasons like clock jitter.
* Some blocks might need 200Mhzs and some might need 100Mhz - point is different frequencies just on one small chip.
* A concept of ppm(clock accuracy) comes in, when ever quartz is acquired, it comes with a **x ppm error**.

* The frequency of a quartz crystal can deviate from its nominal value due to several factors, which are typically expressed in parts per million (ppm).
    * A crystal with a higher ppm error may deviate more from the desired frequency, affecting the precision of timing in electronic systems.
    * Frequency stability characterizes the maximum frequency variation over the operating temperature range. Crystals with higher ppm errors may exhibit larger frequency variations with temperature changes,
      impacting the reliability of timing references, especially in applications exposed to extreme temperature conditions.
    * The total frequency error of a crystal is the sum of errors contributed by frequency tolerance, frequency stability, and aging. A higher ppm error in any of these components can lead to a larger total
      frequency error, affecting the overall accuracy of the crystal in maintaining precise timing references.

#### Digital-to-Analog Converter :

* A Digital to Analog Converter (DAC) converts a digital input signal into an analog output signal. The digital signal is represented with a binary code, which is a combination of bits 0 and 1. 
* A Digital to Analog Converter (DAC) consists of a number of binary inputs and a single output.

* In general, the number of binary inputs of a DAC will be a power of two.
* There are two types of DACs :
    * Weighted Resistor DAC
    * R-2R Ladder DAC
 
  In our `VSDBabySoC` design , we are using a 10-bit DAC.

</details>

<details>

<summary>Day 10 - BabySoC Modelling</summary>

#### What is Modelling?

* Modelling and simulation (M&S) is the use of a physical/logical representation of a given system to generate data and help determine decisions/make predictions about the system.
* M&S is widely used in the VLSI domain.

#### Purpose of modelling :

System models are specifically developed to support analysis, specification, design, verification and validation of a system, as well as to communicate certain information.

#### **What are we modelling? (VSDBabySoC)**

* Some initial input signals will be fed into `vsdbabysoc` module.
* PLL will start generating the proper `CLK` for the circuit.
* Clock signal `CLK` will make the `rvmyth` to execute instructions and some values are generated, these values are used by `DAC` core to provide the final output signal named `OUT`
* There are 3 main elements (IP cores) and a wrapper as SoC and also a testbench module.

#### Challenges in modelling mixed signal blocks :

* `RVMYTH` is a digital block, so yes we can use a HDL for designing and check its functionality using a testbench.
* But! `DAC` and `PLL` are analog what to do? 😥

* Because verilog can’t synthesize analog design,hence We are going to simulate it using verilog - we will be using data-types such `real`.
* Our goal is to be able to simulate **“functionality” - to verify its logical correctness**.

1) [Here](https://github.com/shivanishah269/risc-v-core) the repo we used as a reference to model the `RVMYTH`.
2) [Here](https://github.com/vsdip/rvmyth_avsdpll_interface) is the repo we used as a reference to model the `PLL`.
3) [Here](https://github.com/vsdip/rvmyth_avsddac_interface) is the repo we used as a reference to model the `DAC`.

Note :

* RVMYTH is designed and created by the TL-Verilog language. So we need a way for compile and transform it to the Verilog language and use the result in our SoC. Here the `sandpiper-saas` could help us do the 
  job.

#### Step-by-Step process of modelling :

1) Install These Required Packages:

        $ sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io
        $ sudo chmod 666 /var/run/docker.sock
        $ cd ~
        $ pip3 install pyyaml click sandpiper-saas

2) `git clone https://github.com/manili/VSDBabySoC.git` - clone this repo containing VSDBabySoC design files and testbench.
3) cd `/home/subhasis/VSDBabySoC`
4) `sandpiper-saas -i ./src/module/*.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/` - to translate `.tlv` definition of `rvmyth` into `.v` definition.

     ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c4a680be-ad7c-4f10-b85a-92b488bf3ba6)

5) `iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module` - to compile and simulate vsdbabysoc design.
6) cd `output`
7) `./pre_synth_sim.out` - To generate pre_synth_sim.vcd file,which is our simulation waveform file.
8) gtkwave `pre_synth_sim.out` - to open simulation waveform in gtkwave tool.

   ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/91dadff7-515e-49cf-a47c-dbc80f83ba30)

**Simulation Waveform :**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/6e8bb27a-1624-4d2b-a252-c825b6973894)

In this picture we can see the following signals:

* `CLK`: This is the input `CLK` signal of the RVMYTH core. This signal comes from the `PLL`, originally.
* `reset`: This is the input `reset` signal of the `RVMYTH` core. This signal comes from an external source, originally.
* `OUT`: This is the output `OUT` signal of the `VSDBabySoC` module. This signal comes from the DAC (due to simulation restrictions it behaves like a digital signal which is incorrect), originally.
* `RV_TO_DAC[9:0]`: This is the `10-bit output [9:0] OUT` port of the RVMYTH core. This port comes from the `RVMYTH register #17`, originally.
* `OUT`: This is a `real` datatype net which can simulate analog values. It is the output net real `OUT` signal of the DAC module. This signal comes from the DAC, originally.

</details>

<details>

<summary>Day 11 - Post-Synthesis Simulation (GLS) of BabySoC</summary>

#### Why do pre-synthesis Simulation? Why not just do post-synthesis Simulation? :

* Pre-synthesis simulation is done according to the logic we have designed for and written -> only functionality.
* Post synthesis simulation / ‘gate level simulation’ is done after synthesis considering each and every gate delays into account. It reports the violations in both functionality and timing.
* This also shows the mismatches we are likely to get due to wrong usage of operators and inference of latches.
    * For ex: using ‘X’(simulator terms/ synthesizer terms) - ‘Unknown’/“Don’t care”.


#### GLS: a brief introduction :

* The term "gate level" refers to the netlist view of a circuit, usually produced by logic synthesis.
* So while RTL simulation is pre-synthesis, GLS is post-synthesis.
* The netlist view is a complete connection list consisting of gates and IP models with full functional
   and timing behavior.
* RTL simulation is a zero delay environment and events generally occur on the active clock edge.
* GLS can be zero delay also, but is more often used in unit delay or full timing mode.

* Gate level simulation is used to boost the confidence regarding implementation of a design and can help verify dynamic circuit behaviour, which cannot be verified accurately by static methods. It is a
  significant step in the verification process.

**To synthesize the VSDBabySoC design,**

* 1st we need `.db` format for `avsddac.lib`, `avsdpll.lib` & `sky130_fd_sc_hd__tt_025C_1v80.lib` using Synopsys Library Compiler (`lc_shell`) :

      cd /home/subhasis/VSDBabySoC/src/lib
      read_lib sky130_fd_sc_hd__tt_025C_1v80.lib
      write_lib -format db sky130_fd_sc_hd__tt_025C_1v80 -output sky130_fd_sc_hd__tt_025C_1v80.db

  ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c716f41f-5fe6-49c6-96b8-1ad730ec26b6)

* Upon debugging these errors, as shown below for `avsdpll.lib`, we were also able to obtain `avsdpll.db` and `avsddac.db` using same method as mentioned above :

    ![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/c471eddd-6a32-4349-93aa-281652e5b82d)

* To Synthesize the design,following commands were used :

        set target_library /home/subhasis/VSDBabySoC/src/lib/sky130_fd_sc_hd__tt_025C_1v80.db
        set link_library {* /home/subhasis/VSDBabySoC/src/lib/sky130_fd_sc_hd__tt_025C_1v80.db /home/subhasis/VSDBabySoC/src/lib/avsdpll.db /home/subhasis/VSDBabySoC/src/lib/avsddac.db}
        set search_path {/home/subhasis/VSDBabySoC/src/include /home/subhasis/VSDBabySoC/src/module} # set path where tool will search for design modules/files.
        read_file {sandpiper_gen.vh  sandpiper.vh  sp_default.vh  sp_verilog.vh clk_gate.v rvmyth.v rvmyth_gen.v vsdbabysoc.v} -autoread -top vsdbabysoc # read all mentioned files in list and set top design 
        `vsdbabysoc`
        link #link design with library and resolve all references(instantiations)
        compile_ultra
        write_file -format verilog -hierarchy -output /home/subhasis/VSDBabySoC/output/vsdbabysoc_net.v # write out netlist file in verilog format at specified output location.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/5307cf34-f461-4776-85fc-81a620a9df48)

* In `/home/subhasis/VSDBabySoC`, execute these commands to perform post-synthesis simulation :

        iverilog -DFUNCTIONAL -DUNIT_DELAY=#1 -o ./output/post_synth_sim.out ./src/gls_model/primitives.v ./src/gls_model/sky130_fd_sc_hd.v ./output/vsdbabysoc_net.v ./src/module/avsdpll.v 
        ./src/module/avsddac.v ./src/module/testbench.v
  
        cd output
        ./post_synth_sim.out
        gtkwave dump.vcd

As we can observe in the image below, our post-synth (top) and pre-synth(bottom) are same :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/16e4ff19-5035-4d65-a723-fa31af54cc29)

**Now,our next task is to develop constraints for our design and optimize it further.**

</details>

<details>

<summary>Day 12 - Synthesis & Timing Analysis of BabySoC</summary>

Now, we can continue with synthesis of our design according to constraints mentioned below :


    create_clock [get_pins pll/CLK] -name clk -period 10 -waveform {0 5}
    set_load -pin_load 0.5 [get_ports OUT]
    set_load -min -pin_load 0.5 [get_ports OUT]
    set_clock_latency 1 [get_clocks clk]
    set_clock_latency -source 2 [get_clocks clk]
    set_clock_uncertainty 0.5  [get_clocks clk]
    set_max_delay 10 -from [get_pins dac/OUT] -to [get_ports OUT]
    set_input_delay -clock clk -max 4 [get_ports VCO_IN]
    set_input_delay -clock clk -min 1 [get_ports VCO_IN]
    set_input_delay -clock clk -max 4 [get_ports ENb_CP]
    set_input_delay -clock clk -min 1 [get_ports ENb_CP]
    set_input_transition -max 0.4 [get_ports VCO_IN]
    set_input_transition -min 0.1 [get_ports VCO_IN]
    set_input_transition -max 0.4 [get_ports ENb_CP]
    set_input_transition -min 0.1 [get_ports ENb_CP]

Timing report after Synthesis was done with above constraints :

    ****************************************
    Report : timing
            -path full
            -delay max
            -max_paths 1
    Design : vsdbabysoc
    Version: T-2022.03-SP5-6
    Date   : Tue Jun  4 15:56:46 2024
    ****************************************
    
    Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
    Wire Load Model Mode: top
    
      Startpoint: core/CPU_is_addi_a3_reg
                  (rising edge-triggered flip-flop clocked by clk)
      Endpoint: core/CPU_Xreg_value_a4_reg[27][31]
                (rising edge-triggered flip-flop clocked by clk)
      Path Group: clk
      Path Type: max
    
      Des/Clust/Port     Wire Load Model       Library
      ------------------------------------------------
      vsdbabysoc         Small                 sky130_fd_sc_hd__tt_025C_1v80
    
      Point                                                                Incr       Path
      ---------------------------------------------------------------------------------------
      clock clk (rise edge)                                                0.00       0.00
      clock network delay (ideal)                                          3.00       3.00
      core/CPU_is_addi_a3_reg/CLK (sky130_fd_sc_hd__dfxtp_1)               0.00       3.00 r
      core/CPU_is_addi_a3_reg/Q (sky130_fd_sc_hd__dfxtp_1)                 0.29       3.29 f
      core/U474/Y (sky130_fd_sc_hd__nor2_1)                                0.13       3.41 r
      core/U476/Y (sky130_fd_sc_hd__nand2_1)                               0.11       3.52 f
      core/U9/Y (sky130_fd_sc_hd__inv_2)                                   0.53       4.05 r
      core/U479/X (sky130_fd_sc_hd__xor2_1)                                0.19       4.24 f
      core/U569/Y (sky130_fd_sc_hd__a21oi_1)                               0.26       4.49 r
      core/U571/Y (sky130_fd_sc_hd__o21ai_1)                               0.12       4.61 f
      core/U574/Y (sky130_fd_sc_hd__a21oi_1)                               0.20       4.81 r
      core/U576/Y (sky130_fd_sc_hd__o21ai_1)                               0.12       4.93 f
      core/U581/Y (sky130_fd_sc_hd__a21oi_1)                               0.20       5.14 r
      core/U583/Y (sky130_fd_sc_hd__o21ai_1)                               0.12       5.25 f
      core/U587/Y (sky130_fd_sc_hd__a21oi_1)                               0.20       5.46 r
      core/U589/Y (sky130_fd_sc_hd__o21ai_1)                               0.12       5.57 f
      core/U344/Y (sky130_fd_sc_hd__a21oi_1)                               0.20       5.78 r
      core/U213/Y (sky130_fd_sc_hd__o21ai_1)                               0.12       5.89 f
      core/U343/Y (sky130_fd_sc_hd__a21oi_1)                               0.20       6.10 r
      core/U210/Y (sky130_fd_sc_hd__o21ai_1)                               0.12       6.21 f
      core/U342/Y (sky130_fd_sc_hd__a21oi_1)                               0.20       6.42 r
      core/U209/Y (sky130_fd_sc_hd__o21ai_1)                               0.12       6.53 f
      core/U341/Y (sky130_fd_sc_hd__a21oi_1)                               0.20       6.74 r
      core/U215/Y (sky130_fd_sc_hd__o21ai_1)                               0.12       6.85 f
      core/U96/X (sky130_fd_sc_hd__a21o_1)                                 0.18       7.03 f
      core/U942/COUT (sky130_fd_sc_hd__fa_1)                               0.40       7.43 f
      core/U94/X (sky130_fd_sc_hd__a21o_1)                                 0.18       7.61 f
      core/U905/COUT (sky130_fd_sc_hd__fa_1)                               0.38       7.99 f
      core/U887/COUT (sky130_fd_sc_hd__fa_1)                               0.39       8.38 f
      core/U1370/COUT (sky130_fd_sc_hd__fa_1)                              0.40       8.78 f
      core/U36/COUT (sky130_fd_sc_hd__fa_2)                                0.37       9.15 f
      core/U87/Y (sky130_fd_sc_hd__clkinv_1)                               0.06       9.20 r
      core/U613/Y (sky130_fd_sc_hd__o21ai_1)                               0.06       9.27 f
      core/U352/COUT (sky130_fd_sc_hd__fa_1)                               0.38       9.65 f
      core/U348/COUT (sky130_fd_sc_hd__fa_1)                               0.39      10.04 f
      core/U35/COUT (sky130_fd_sc_hd__fa_1)                                0.39      10.43 f
      core/U33/COUT (sky130_fd_sc_hd__fa_1)                                0.41      10.85 f
      core/U81/X (sky130_fd_sc_hd__a21o_1)                                 0.18      11.03 f
      core/U347/COUT (sky130_fd_sc_hd__fa_1)                               0.38      11.41 f
      core/U351/COUT (sky130_fd_sc_hd__fa_1)                               0.39      11.80 f
      core/U617/X (sky130_fd_sc_hd__xor2_1)                                0.22      12.02 r
      core/U618/Y (sky130_fd_sc_hd__nand2_2)                               0.19      12.21 f
      core/U627/Y (sky130_fd_sc_hd__o22ai_1)                               0.16      12.37 r
      core/CPU_Xreg_value_a4_reg[27][31]/D (sky130_fd_sc_hd__dfxtp_1)      0.00      12.37 r
      data arrival time                                                              12.37
    
      clock clk (rise edge)                                               10.00      10.00
      clock network delay (ideal)                                          3.00      13.00
      clock uncertainty                                                   -0.50      12.50
      core/CPU_Xreg_value_a4_reg[27][31]/CLK (sky130_fd_sc_hd__dfxtp_1)
                                                                           0.00      12.50 r
      library setup time                                                  -0.09      12.41
      data required time                                                             12.41
      ---------------------------------------------------------------------------------------
      data required time                                                             12.41
      data arrival time                                                             -12.37
      ---------------------------------------------------------------------------------------
      slack (MET)                                                                     0.03
    
    
      Startpoint: dac/OUT (internal path startpoint)
      Endpoint: OUT (output port)
      Path Group: default
      Path Type: max
    
      Des/Clust/Port     Wire Load Model       Library
      ------------------------------------------------
      vsdbabysoc         Small                 sky130_fd_sc_hd__tt_025C_1v80
    
      Point                                    Incr       Path
      -----------------------------------------------------------
      input external delay                     0.00       0.00 r
      dac/OUT (avsddac)                        0.00       0.00 r
      OUT (out)                                0.87       0.87 r
      data arrival time                                   0.87
    
      max_delay                               10.00      10.00
      output external delay                    0.00      10.00
      data required time                                 10.00
      -----------------------------------------------------------
      data required time                                 10.00
      data arrival time                                  -0.87
      -----------------------------------------------------------
      slack (MET)                                         9.13
    
    
    1


#### What are PVT Corners?

* **PVT (Process, Voltage, Temperature)** are the three key factors that impact the performance and behavior of integrated circuits in VLSI design. Here is a summary of how each of these factors affects circuit 
  design:

1. Process (P):
   - Process variation refers to deviations in the semiconductor fabrication process, such as variations in impurity concentration, oxide thickness, and transistor dimensions.
   - These process variations can cause changes in transistor parameters like threshold voltage, mobility, and current drive, which in turn impact the circuit delay and performance.
   - Circuits designed with a "fast" process will have lower delays, while "slow" process corners will have higher delays.

2. Voltage (V): 
   - The supply voltage of the chip can deviate from the optimal value during operation due to factors like noise, IR drop, and voltage regulator variations.
   - Higher supply voltage leads to increased current and faster charging/discharging of capacitances, resulting in lower delays. Lower voltage has the opposite effect.

3. Temperature (T):
   - The operating temperature of the chip can vary widely depending on the environment and power dissipation within the chip.
   - Higher temperatures generally decrease carrier mobility, leading to increased delays. However, in sub-65nm technologies, a "temperature inversion" effect can occur where delays actually increase at lower 
     temperatures.

Engineers must design integrated circuits to function correctly across all possible PVT corners - the combinations of process, voltage, and temperature extremes.

This is done through static timing analysis (STA) to ensure timing constraints are met under all conditions.

Accounting for PVT variations is crucial for robust and reliable chip design.

#### Lab - To synthesize BabySoC design using different PVT Corner library files (.lib/.db) and tabulate Worst Negative/Setup Slack (WNS) & Worst Hold Slack (WHS) values :

* Download the `Skywater 130nm PDK` timing libraries for different PVTs from this given link ![](https://github.com/efabless/skywater-pdk-libs-sky130_fd_sc_hd/tree/master/timing) to the path 
  `/home/subhasis/VSDBabySoC/src/timing_libs`

* Now to convert all the `.lib ` file formats to `.db` format execute the following steps :

* cd `/home/subhasis/VSDBabySoC/src/timing_libs`
* lc_shell # Invoke lc_shell tool
* Use the following script to convert all `.lib` to `.db` file format within `timing_libs` directory. Place this script inside `lib_to_db_convert.tcl` and `source` this TCL Script in lc_shell to execute it :

        set libs [glob *.lib]
        set m1 ""
        set library_name ""
        foreach lib_name $libs {
         
        regexp {(.*)\.lib} $lib_name m1 library_name
        
        read_lib $lib_name
        write_lib $library_name -format db -output ${library_name}.db
        }

* To Synthesize the BabySoC Design for different PVT Corners execute the following steps :

  1) cd `/home/subhasis/VSDBabySoC`
  2) create a `sta_mul_pvt.tcl` file and put the following script to synthesize the BabySoC design with different PVT Corners and also report the corresponding `Worst Negative/Setup Slack (WNS) & Worst Hold 
     Slack (WHS)` into a `.rpt` file.

            set m1 ""
            set pvt ""
            set FH [open report_timing.rpt w]
            puts $FH "PVT_Corner\tWNS\tWHS"
            
            set lib_files [glob -directory /home/subhasis/VSDBabySoC/src/timing_libs/ -type f *.db]
            
            foreach lib_file_paths $lib_files {
            
            regexp {.*\/sky130_fd_sc_hd__(.*)\.db$} $lib_file_paths m1 pvt
            
            set timing_report_fast_mode true
            
            
            set target_library $lib_file_paths
            set link_library {* /home/subhasis/VSDBabySoC/src/lib/avsdpll.db /home/subhasis/VSDBabySoC/src/lib/avsddac.db}
            lappend link_library $target_library
            set search_path {/home/subhasis/VSDBabySoC/src/include /home/subhasis/VSDBabySoC/src/module}
            read_file {sandpiper_gen.vh  sandpiper.vh  sp_default.vh  sp_verilog.vh clk_gate.v rvmyth.v rvmyth_gen.v vsdbabysoc.v} -autoread -top vsdbabysoc
            source /home/subhasis/VSDBabySoC/src/sdc/vsdbabysoc_synthesis.sdc
            link
            compile_ultra
            
            set wns [get_attribute [get_timing_paths -delay_type max -max_paths 1] slack]
            set whs [get_attribute [get_timing_paths -delay_type min -max_paths 1] slack]
            
            puts $FH "$pvt\t$wns\t$whs"
            
            reset_design
            }
            
            close $FH
     
  3) Invoke dc_shell and `source` the above script to synthesize the BabySoC design with different PVT Corners and also report the corresponding `Worst Negative/Setup Slack (WNS) & Worst Hold 
     Slack (WHS)` into a `.rpt` file.

  4) After the design has been synthesized for all `PVT` corners, open `report_timing.rpt` file in present working directory in a text editor to view all the `WNS` & `WHS` for different PVT Corners.

**Table for Worst Negative/Setup Slack (WNS) & Worst Hold Slack (WHS) for different available PVT corners, for our BabySoC Design :**

| PVT_Corner   | WNS        | WHS         |
| ------------ | ---------- | ----------- |
| ff_100C_1v65 | 0.00459766 | \-0.244979  |
| ff_100C_1v95 | 0.227859   | \-0.298619  |
| ff_n40C_1v56 | 0.0493441  | \-0.201714  |
| ff_n40C_1v65 | 0.0182953  | \-0.23863   |
| ff_n40C_1v76 | 0.032217   | \-0.269796  |
| ff_n40C_1v95 | 0.0913324  | \-0.307088  |
| ss_100C_1v40 | 0.00604248 | 0.413952    |
| ss_100C_1v60 | 1.7014     | 0.14934     |
| ss_n40C_1v28 | \-2.14636  | 1.2782      |
| ss_n40C_1v35 | 0.00161362 | 0.825907    |
| ss_n40C_1v40 | 0.00352478 | 0.607227    |
| ss_n40C_1v44 | 0.00133705 | 0.498978    |
| ss_n40C_1v60 | 0.00631809 | 0.169568    |
| ss_n40C_1v76 | 0.00544834 | \-0.0055871 |
| tt_025C_1v80 | 0.198813   | \-0.184026  |
| tt_100C_1v80 | 0.00269318 | \-0.179197  |

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/803304c8-8c9b-4f4e-becf-98696d86edf3)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/21b91919-8647-407f-9a05-a44be48e34be)

* Hence fromm analysing the data from above table , the following two PVT corners were selected for multi-mode multi corner analysis for our BabySoC design :
    * `ff_n40C_1v95` - PVT corner for hold analysis (Worst WHS observed).
    * `ss_n40C_1v28` - PVT corner for setup analysis (Worst WNS observed).



</details>

<details>

<summary>Day 13 - Floorplanning & Power Planning of BabySoC</summary>


#### Physical Design Flow :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/025b0f94-2fec-4585-8868-458af7c61506)


Physical Design is the process of translating the gate level netlist into a physical layout. This physical layout consists of various metal shapes and sizes which can be drawn onto masks and manufactured on the 
silicon wafer.

The Physical Design process can be broken down into multiple stages as illustrated below. It is often an iterative process where a number of optimizations are performed at each step to meet the design performance, area & power requirements.

**Floorplanning** :

Floorplanning is the first step of physical design. The design is first partitioned into various smaller subsystems based on the system architecture and design requirements.  Floorplanning determines the aspect 
ratio and area of the layout. Here we create the placement rows for standard cells and fix the placement of I/Os around the boundary. Any macros in the design are also placed during the floorplan stage.

**Power planning** is also typically done during floorplanning. The power grid network is created to distribute power to all the std cells rows, macros and all other components of the design. If there are any 
special IPs being used in the design then all the IP integration guidelines are also considered in floorplanning.

A good floorplan is very critical to the overall quality of your design.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a7840b37-9a89-4e92-89d5-71db9e1594b2)
 

**Logic Placement** :

In this stage all the standard cells in the design are placed and assigned a legal location. After the placement EDA tools performs a number of optimizations to improve placement and congestion. A bad placement 
might lead to larger area utilization and timing issues.

EDA tools also use timing driven placement algorithms to optimize the placement while considering the timing requirements of the design.

 

**Clock Tree Synthesis** :

During the Floorplanning & placement stage, the clock is considered as an ideal network. The optimizations in the placement stage are performed based on the assumption of an ideal clock reaching to all flops at 
the same time. In CTS, a clock network is created to distribute the clock to all flops. This clock tree is built using buffers or inverters along the clock paths of design in order to achieve zero/minimum skew 
based on design requirement. A good quality clock network is very crucial to meet the timing requirements of the design.

**Routing** :

Once all the standard cells are legally placed and the clock network is synthesized, all the connecting data nets need to be laid out on the metal layers. This is done during the routing stage. After routing all the nets, a number of optimizations are performed based on the design timing requirements and analysis.

 

**Timing Analysis & Signoff** :

After the design Routing, static timing analysis is performed on the design. This step is critical to analyze the performance of the design. During STA, we break down the design into timing paths and calculate 
the signal propagation delay along each path. Then each path is checked for violations of timing constraints. If any path is violated then these violations need to be addressed before signing off on the design.

The timing signoff ensures that all the design elements are meeting the specified timing requirements and the design is working at the desired frequency.

 

**Physical Verification & Signoff** :

After the routing is completed, the layout must be completely verified to ensure its correct electrical and logical functionality. The physical verification signoff ensures that the design meets all the 
fabrication specified rules and can be easily manufactured. Various checks that are performed at this stage includes :

* DRC (Design Rule Check)
* LVS (Layout Vs Schematic)
* ERC (Electrical Rule Check)
* Antenna check
* EM (Electromigration Analysis)

Once the physical verification is done, the layout is streamed out in the form of a GDSII or OASIS file for fabrication which is called **design tapeout**.


#### What is Floorplanning? :

In VLSI design, **Floorplanning** is a crucial step in physical design that involves placing blocks and macros in the chip or core area.

The primary objectives of floorplanning are to minimize area, timing, wire length, and power consumption while ensuring easy routing and reliability.

Here are the key aspects of floorplanning:

#### Inputs for Floorplanning :

* Gate level netlist (.v)
* Physical & Logical Libraries. (.lefs & .libs for all standard cell,macros,IO Pads etc.)
* Synopsys design constraints (.sdc).
* RC Tech File (TLU+ file) - to determine RC values of interconnect layers/metal layers of technology node used in our design, and hence provide RC values for computation of wire delays.
* Technology File (.tf).
* Physical Partitioning information of the design.
* Floorplanning Parameters like height,width,aspect ratio etc.


### Outputs of Floorplanning
1. **Die/Core Area**: The physical description of the ASIC design.
2. **IO Pad Information**: The placement of I/O pins.
3. **Placed Macros Information**: The placement of macros.
4. **Standard Cell Placement Areas**: The areas where standard cells are placed.
5. **Power Grid Design**: The power distribution plan.
6. **Blockages**: The defined regions where cells cannot be placed.

Sources:

1) https://www.vlsisystemdesign.com/floorplanning/
2) https://www.vlsi4freshers.com/2020/01/floorplanning.html
3) https://www.physicaldesign4u.com/2019/12/floorplanning-floor-planning-is-art-of.html
4) http://vlsibegin.blogspot.com/p/floorplanning_7.html
5) https://vlsitutor.com/nots/introduction-to-floorplan/


#### Types of floorplan techniques used in Full Chip plan :

1. **Abutted Floorplan**: This technique involves channel-less placement of blocks, where there is no gap between the blocks.
2. **Non-Abutted Floorplan**: In this technique, blocks are placed with a gap between them, and connections are made through routing nets.
3. **Mix of Both**: This approach combines abutted and non-abutted techniques, using both channels and direct connections.
   
![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/aed37295-7821-4c80-9e6d-8bd190b8faa0)


### Floorplan Control Parameters
1. **Aspect Ratio**: The ratio of the height to the width of the chip, which affects routing resources and congestion.
2. **Core Utilization**: The percentage of the core area occupied by standard cells, macros, and blockages.

### Floorplan Steps
1. **Define Width and Height**: Determine the size of the core and die.
2. **IO Pin Placement**: Place I/O pins at the boundary of the chip.
3. **Power Planning**: Plan the power grid and power distribution.
4. **Macro Placement**: Place macros manually using flylines.
5. **Standard Cell Row Creation**: Create areas for standard cell placement.
6. **Blockages**: Define blockages to ensure proper placement and routing.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/7c735fc4-a7a5-43e5-b0b5-053aae3a0876)

### Key Terms
1. **Standard Cell Row**: The area where standard cells are placed, divided into rows with varying heights.
2. **Flylines**: Virtual connections between macros and IO pads, helping in logical placement and reducing routing resources.
3. **Halo (Keep Out Margin)**: The region around fixed macros where other macros and standard cells cannot be placed.


### Issues with Bad Floorplanning
1. **Area and Power Consumption**: A bad floorplan can increase the area and power consumption of the chip.
2. **Reliability**: It can affect the reliability of the chip.
3. **Timing Closure**: A bad floorplan can make timing closure difficult.

### Qualifying a Good Floorplan
1. **Meet Timing and Congestion Constraints**: Ensure that the floorplan meets timing and congestion constraints.
2. **Optimize Area and Power**: Optimize the area and power consumption of the chip.
3. **Ensure Routing and Placement**: Ensure that the floorplan allows for easy routing and placement.

### Automatic Floorplan Options
1. **Automatic Macro Placement**: Most PnR tools provide automatic floorplan options, but these may not always produce optimal results.

### Macro Placement Tips
1. **Understand Pins and Orientation**: Understand the pin requirements and orientation of macros.
2. **Follow Data Flow**: Place macros following the data flow and hierarchy.
3. **Ensure Proper Orientation**: Ensure that all macro pins point towards the core logic.
4. **Channel Size**: Ensure that channels between macros are large enough for routing and power grids.

### Blockages
1. **Soft Blockages**: Partial blockages that can be removed during placement.
2. **Hard Blockages**: Permanent blockages that cannot be removed.
3. **Partial Blockages**: Blockages that can be removed during placement but are used to prevent congestion.

#### What is Power Planning ?

Power planning in VLSI design is the process of creating a power distribution network (PDN) to provide power to all the components of the chip, including macros, standard cells, and other cells. The main objectives of power planning are:

1. **Maintain a stable voltage** across the chip with minimal noise.
2. **Avoid electromigration** and self-heating issues.
3. **Consume minimal chip area and wiring resources**
4. **Meet IR drop budget targets** for reliable operation.

The key steps in power planning are:

1. **Calculating the number of power pins required**, based on the total power consumption of the chip.
2. **Determining the number of power rings, stripes, and rails** needed to distribute power uniformly.
3. **Sizing the width of power rings and stripes** to handle the required current.
4. **Analyzing IR drop** and taking measures to keep it within acceptable limits.

The power distribution hierarchy consists of:

1. **Power pads** that bring power from outside the chip.
2. **Power rings** around the core area.
3. **Power stripes** that distribute power horizontally and vertically across the core.
4. **Power rails** that connect the power stripes to the standard cells.

Power planning is typically done during the floorplanning stage, before signal routing. It involves creating a power mesh using the top metal layers, which have lower resistance compared to lower metal layers. 

The power mesh is connected to the standard cells through power rails.

Proper power planning is critical in modern VLSI designs to ensure reliable operation and meet power budget constraints, especially in deep sub-micron technologies where power has become a primary concern over 
area and performance.

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/885628b2-ad44-468e-b2cd-aaed55df3199)



#### Lab - Floorplanning of VSDBabySoC :

* **Downloading Physical design Collaterals :**

    * `git clone https://github.com/efabless/skywater-pdk-libs-sky130_fd_sc_hd/tree/master` - to download all Technology file (`.techlef`) for skywater130nm pdk and all the `.lef` files for all standard cells.
    * `git clone https://github.com/bharath19-gs/synopsys_ICC2flow_130nm` - to download Technology file (`.tf`) for skywater130nm pdk and RC Tech file (parasitics file) in `.itf` format for the PDK.
    * `git clone https://github.com/kunalg123/icc2_workshop_collaterals` - to download all the scripts to setup and run Physical Design flow in ICC2 Compiler tool.
 
* The Interconnect Technology Format (ITF) file is a critical component in the physical design of integrated circuits (ICs). Here is a concise summary of what the ITF file contains and how it is used:

The ITF file provides a detailed description of the process technology, including the physical attributes of the conductor and dielectric layers. Specifically, it specifies:

* The thickness, minimum width, and minimum spacing of each conductor layer.
* The sheet resistance (RPSQ) of each conductor layer.
* The thickness and dielectric constant (ER) of each dielectric layer.
* The resistivity (RHO) and area (AREA) of each via layer.

This information is used to accurately model the parasitic resistance and capacitance (RC) of the interconnect in the design. 

The ITF file is a critical input for parasitic extraction tools to generate the RC parasitics needed for timing, signal integrity, power, and reliability analysis.

Additionally, the ITF file can be used to generate TLU+ files, which are another important technology file used in physical design.

To convert `.itf` file to `.tluplus` format,perform the following steps :

    1) cd `/home/subhasis/VSDBabySoC/synopsys_ICC2flow_130nm/synopsys_skywater_flow_nominal/itf_files`
    2) In Linux Terminal,
        grdgenxo -itf2TLUPlus -i skywater130.nominal.itf -o skywater130.nominal.tluplus # to generate TLUplus RC Tech file from .itf file format using StarRC tool.


![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/123f1f0e-6005-4579-82a4-24af99682e49)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/69e83696-1ab6-4747-b580-2f9674cbde7a)



**SDC Constraints Used for Synthesis :**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/d4e89316-d137-451c-a79d-5e03c07ae5b2)

**QoR report :**

    Information: Updating design information... (UID-85)
     
    ****************************************
    Report : qor
    Design : vsdbabysoc
    Version: T-2022.03-SP5-6
    Date   : Fri Jun 21 14:39:04 2024
    ****************************************
    
    
      Timing Path Group 'clk'
      -----------------------------------
      Levels of Logic:              39.00
      Critical Path Length:          9.37
      Critical Path Slack:           0.03
      Critical Path Clk Period:     10.00
      Total Negative Slack:          0.00
      No. of Violating Paths:        0.00
      Worst Hold Violation:         -0.18
      Total Hold Violation:        -28.27
      No. of Hold Violations:      585.00
      -----------------------------------
    
      Timing Path Group 'default'
      -----------------------------------
      Levels of Logic:               1.00
      Critical Path Length:          0.87
      Critical Path Slack:           9.13
      Critical Path Clk Period:       n/a
      Total Negative Slack:          0.00
      No. of Violating Paths:        0.00
      Worst Hold Violation:          0.00
      Total Hold Violation:          0.00
      No. of Hold Violations:        0.00
      -----------------------------------
    
    
      Cell Count
      -----------------------------------
      Hierarchical Cell Count:          1
      Hierarchical Port Count:         12
      Leaf Cell Count:               2743
      Buf/Inv Cell Count:             578
      Buf Cell Count:                   2
      Inv Cell Count:                 576
      CT Buf/Inv Cell Count:            0
      Combinational Cell Count:      2067
      Sequential Cell Count:          676
      Macro Count:                      0
      -----------------------------------
    
    
      Area
      -----------------------------------
      Combinational Area:    11407.190234
      Noncombinational Area: 13532.978775
      Buf/Inv Area:           2169.580732
      Total Buffer Area:             7.51
      Total Inverter Area:        2162.07
      Macro/Black Box Area:      0.000000
      Net Area:                  0.000000
      -----------------------------------
      Cell Area:             24940.169009
      Design Area:           24940.169009
    
    
      Design Rules
      -----------------------------------
      Total Number of Nets:          2763
      Nets With Violations:             0
      Max Trans Violations:             0
      Max Cap Violations:               0
      -----------------------------------
    
    
      Hostname: sfalvsd
    
      Compile CPU Statistics
      -----------------------------------------
      Resource Sharing:                    5.01
      Logic Optimization:                  3.67
      Mapping Optimization:                3.90
      -----------------------------------------
      Overall Compile Time:               34.67
      Overall Compile Wall Clock Time:    35.32
    
      --------------------------------------------------------------------
    
      Design  WNS: 0.00  TNS: 0.00  Number of Violating Paths: 0
    
    
      Design (Hold)  WNS: 0.18  TNS: 28.27  Number of Violating Paths: 585
    
      --------------------------------------------------------------------

**Area Report :**

     
    ****************************************
    Report : area
    Design : vsdbabysoc
    Version: T-2022.03-SP5-6
    Date   : Fri Jun 21 14:39:04 2024
    ****************************************
    
    Library(s) Used:
    
        sky130_fd_sc_hd__tt_025C_1v80 (File: /home/subhasis/VSDBabySoC/src/lib/sky130_fd_sc_hd__tt_025C_1v80.db)
        avsddac (File: /home/subhasis/VSDBabySoC/src/lib/avsddac.db)
        avsdpll (File: /home/subhasis/VSDBabySoC/src/lib/avsdpll.db)
    
    Number of ports:                           19
    Number of nets:                          2775
    Number of cells:                         2744
    Number of combinational cells:           2065
    Number of sequential cells:               676
    Number of macros/black boxes:               2
    Number of buf/inv:                        578
    Number of references:                       4
    
    Combinational area:              11407.190234
    Buf/Inv area:                     2169.580732
    Noncombinational area:           13532.978775
    Macro/Black Box area:                0.000000
    Net Interconnect area:      undefined  (Wire load has zero net area)
    
    Total cell area:                 24940.169009
    Total area:                 undefined
    1

Power Report :

     
    ****************************************
    Report : power
            -analysis_effort low
    Design : vsdbabysoc
    Version: T-2022.03-SP5-6
    Date   : Fri Jun 21 14:39:04 2024
    ****************************************
    
    
    Library(s) Used:
    
        sky130_fd_sc_hd__tt_025C_1v80 (File: /home/subhasis/VSDBabySoC/src/lib/sky130_fd_sc_hd__tt_025C_1v80.db)
        avsddac (File: /home/subhasis/VSDBabySoC/src/lib/avsddac.db)
        avsdpll (File: /home/subhasis/VSDBabySoC/src/lib/avsdpll.db)
    
    
    Operating Conditions: tt_025C_1v80   Library: sky130_fd_sc_hd__tt_025C_1v80
    Wire Load Model Mode: top
    
    Design        Wire Load Model            Library
    ------------------------------------------------
    vsdbabysoc             Small             sky130_fd_sc_hd__tt_025C_1v80
    
    
    Global Operating Voltage = 1.8  
    Power-specific unit information :
        Voltage Units = 1V
        Capacitance Units = 1.000000pf
        Time Units = 1ns
        Dynamic Power Units = 1mW    (derived from V,C,T units)
        Leakage Power Units = 1nW
    
    
    Attributes
    ----------
    i - Including register clock pin internal power
    
    
      Cell Internal Power  =   2.8495 mW   (83%)
      Net Switching Power  = 592.4229 uW   (17%)
                             ---------
    Total Dynamic Power    =   3.4419 mW  (100%)
    
    Cell Leakage Power     =   8.0225 nW
    
    
                     Internal         Switching           Leakage            Total
    Power Group      Power            Power               Power              Power   (   %    )  Attrs
    --------------------------------------------------------------------------------------------------
    io_pad             0.0000            0.0000            0.0000            0.0000  (   0.00%)
    memory             0.0000            0.0000            0.0000            0.0000  (   0.00%)
    black_box          0.0000            0.4454            0.0000            0.4454  (  12.94%)
    clock_network      2.7524            0.0000            0.0000            2.7524  (  79.97%)  i
    register       4.6345e-02        2.0562e-02            5.4668        6.6912e-02  (   1.94%)
    sequential         0.0000            0.0000            0.0000            0.0000  (   0.00%)
    combinational  5.0792e-02            0.1265            2.5557            0.1773  (   5.15%)
    --------------------------------------------------------------------------------------------------
    Total              2.8495 mW         0.5924 mW         8.0225 nW         3.4419 mW
    1

VSDBabySoC Schematic :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/28a8404a-7087-4c17-a5d6-f86207af0282)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a77ad395-da54-4a90-a04b-ebe0a1dc015a)

RVMYTH Core Schematic :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/63ee3939-b705-4cce-aa72-c73a39cc9c0d)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/39d5bcbd-fda7-46e8-9344-c5736353ac70)


Collaterals can be setup in the following files present in this path `/home/subhasis/VSDBabySoC/scripts/PD_flow/` :

* compile_pg_example.tcl
* init_design.mcmm_example.auto_expanded.tcl
* init_design.read_parasitic_tech_example.tcl
* init_design.tech_setup.tcl
* pns_example.tcl
* top.tcl
* write_block_data.tcl

**Setting Up Collaterals required for PD flow :**

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/a969b721-3bf2-4f7a-b38a-cf3f5f37e2f7)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/8a75849f-1682-409c-8320-3c4eb14fce96)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/54a058eb-bcb8-462c-9f27-91b559235d6f)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/bc4fd6db-3572-4af4-8118-f0d4e4fd5a60)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/5e9f61ff-1d24-42bc-b2f4-48e89e8f28ab)

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/de642a3d-ba9d-4f42-bda1-20e6abe55ebf)

Floorplan options used :

    initialize_floorplan -core_utilization 0.45 -core_offset {5} 
    create_keepout_margin -type hard -outer {2 2 2 2} [get_cells -physical_context -filter design_type==macro] # creates a keepout margin around the macros with Specified the padding margin to maintain outside 
                                                                                                                 of  the  design or  cell boundary. This setting is used for physical designs and cells. 
    Keepout margin is a region around the boundary of a macro in which no other cells are placed. 
    Keeping the placement of cells out of such regions avoids congestion and net detouring and produces better Quality of result.

Constraints used for Physical Design flow :

    create_clock [get_pins pll/CLK] -name clk -period 10 -waveform {0 5}
    set_load -pin_load 0.5 [get_ports OUT]
    set_load -min -pin_load 0.5 [get_ports OUT]
    set_clock_uncertainty 0.5  [get_clocks clk]
    set_max_delay 10 -from [get_pins dac/OUT] -to [get_ports OUT]
    set_input_delay -clock clk -max 4 [get_ports VCO_IN]
    set_input_delay -clock clk -min 1 [get_ports VCO_IN]
    set_input_delay -clock clk -max 4 [get_ports ENb_CP]
    set_input_delay -clock clk -min 1 [get_ports ENb_CP]
    set_input_transition -max 0.4 [get_ports VCO_IN]
    set_input_transition -min 0.1 [get_ports VCO_IN]
    set_input_transition -max 0.4 [get_ports ENb_CP]
    set_input_transition -min 0.1 [get_ports ENb_CP]

Note:

* `set_clock_latency`constraint should be present in synthesis stage,but not in physical design stage.
* `set_clock_latency -source` constraint should be used only if clock source is external.

ICC2 Screenshot after floorplanning & Powerplanning :

![image](https://github.com/Subhasis-Sahu/SFAL-VSD/assets/165357439/27d8f8ed-9147-4592-940f-5f1837397b9d)

![image](https://github.com/user-attachments/assets/89ec2f35-57b9-4ae3-995e-8776b337907d)

Screenshot for post-route design with metal layers connecting standard cell routes/connections :

![image](https://github.com/user-attachments/assets/e22945f7-af2a-49c5-a0da-15392941980a)


Proper Filler Cells used :

![image](https://github.com/user-attachments/assets/a32268eb-ee12-4917-a2ef-0efa5eb90357)


Clock Tree Created :

![image](https://github.com/user-attachments/assets/21043221-9f64-4e2d-86db-face56133c6a)

Now, as we have verified the flow is properly working(flow flush done), we can move on to experiment with various options/constraints in the flow to further optimize the design.

</details>

<details>

<summary>Day 14 - Placement of BabySoC</summary>

Placement in VLSI design is a critical step that involves determining the physical locations of standard cells within a chip's core area. This process is essential for optimizing performance, power consumption, and overall design efficiency.

## Overview of Placement

Placement occurs after logic synthesis and before routing in the VLSI design flow. The primary goals of placement include:

- **Timing Optimization**: Ensuring that the placement minimizes delays in signal propagation.
  
- **Power Optimization**: Reducing power consumption by minimizing capacitive loads and optimizing wire lengths.
  
- **Area Optimization**: Efficiently utilizing the chip area to avoid congestion and ensure routability.

## Steps in Placement

Placement can be divided into several key stages:

1. **Pre-Placement**: This initial stage involves checks and the placement of physical-only cells (e.g., end-cap cells, well-tap cells) to ensure a clean design environment before standard cell placement begins.

2. **Global Placement**: During this phase, the tool determines approximate locations for each standard cell based on various constraints such as timing, congestion, and power. This step does not enforce design rule checks (DRCs), allowing for overlaps.

3. **Legalization**: After global placement, the tool adjusts the positions of cells to eliminate overlaps and ensure that all cells are in legal locations according to the design rules. This process may involve flipping cells to match power pin requirements.

4. **High Fanout Net Synthesis (HFNS)**: This step addresses nets with high fanout by distributing the load across multiple drivers and adding buffers as necessary to meet timing constraints[1][2].

5. **Post-Placement Optimization**: After initial placement, further iterations are conducted to refine the design, focusing on timing, congestion, and power optimizations. This may include techniques like scan-chain reordering and tie cell insertion.

## Techniques Used in Placement

Placement can be driven by various priorities, including:

- **Timing-Driven Placement**: Prioritizes minimizing signal delays.
  
- **Congestion-Driven Placement**: Focuses on reducing routing congestion.
  
- **Power-Driven Placement**: Aims to minimize power consumption during operation.

## Importance of Placement

Effective placement is crucial for ensuring that the design meets performance specifications. It influences:

- **Interconnect Delay**: As feature sizes shrink, the delay introduced by interconnects can dominate overall circuit performance. Proper placement can significantly reduce this delay.

- **Routability**: A well-planned placement reduces the total wire length and evenly distributes routing demand, preventing hotspots and ensuring efficient routing paths.

- **Thermal Management**: Placement affects heat distribution across the chip, which is vital for maintaining reliability and performance.

In summary, placement is a multi-step process that plays a vital role in the VLSI design flow, impacting timing, power, area optimization, and overall circuit performance.

Citations:
[1] https://teamvlsi.com/2021/07/placement-steps-in-physical-design.html
[2] https://vlsitalks.com/physical-design/placement/
[3] https://www.physicaldesign4u.com/2020/02/placement.html
[4] https://vlsitutor.com/nots/placement-overview/
[5] https://www.vlsi-backend-adventure.com/placement.html


#### Lab - Placement of VSDBabySoC :

* `create_placement -floorplan -congestion -timing_driven` - The create_placement command performs coarse placement on  the  currentdesign. With the -floorplan option, this includes the placement of hard
                                                             macros as well as standard cells. To avoid placing  hard  macros,  mark the  hard  macros  as fixed with the set_attribute or set_fixed_objects 
                                                             command.

* `place_opt` - The default behavior of this command (1) places the current design, (2) optimizes the placed design  for  timing,  electrical  DRC  violations, area,  power,  and  routability,
                (3) performs incremental placement to optimize timing and  routability,  (4)  further  optimizes  the  placed design, and (5) legalizes the design placement at the end.

* pre_placement check_design report (`/home/subhasis/VSDBabySoC/scripts/PD_flow/rpts_icc2/place_pins/check_design.pre_pin_placement`) :

        ****************************************
         Report : check_design 
         Options: { dp_pre_pin_placement }
         Design : vsdbabysoc
         Version: T-2022.03-SP5
         Date   : Fri Jul 19 12:52:06 2024
        ****************************************
        
        Running atomic-check 'dp_pre_pin_placement'
        
          *** EMS Message summary ***
          ----------------------------------------------------------------------------------------------------
          Total 0 EMS messages : 0 errors, 0 warnings, 0 info.
          ----------------------------------------------------------------------------------------------------
        
          *** Non-EMS message summary ***
          ----------------------------------------------------------------------------------------------------
          Rule         Type   Count      Message
          ----------------------------------------------------------------------------------------------------
          DPPA-268     Warn   2          Didn't find any enabled planning block for %s.
          DPPA-475     Warn   1          Detected dimension mismatch between the boundary and bbox, for b...
          ----------------------------------------------------------------------------------------------------
          Total 3 non-EMS messages : 0 errors, 3 warnings, 0 info.
          ----------------------------------------------------------------------------------------------------
        Information: Non-EMS messages are saved into file 'check_design2024Jul19125206.log'.
        1


* pin_placement report (`/home/subhasis/VSDBabySoC/scripts/PD_flow/rpts_icc2/place_pins/report_port_placement.rpt`) :

        ****************************************
        Report : report_pin_placement
        Design : vsdbabysoc
        Version: T-2022.03-SP5
        Date   : Fri Jul 19 12:52:06 2024
        ****************************************
        block vsdbabysoc pin OUT layer met4 side 4 offset 626.92
        block vsdbabysoc pin reset layer met5 side 3 offset 340.24
        block vsdbabysoc pin VCO_IN layer met5 side 3 offset 948.84
        block vsdbabysoc pin ENb_CP layer met4 side 2 offset 937.88
        block vsdbabysoc pin ENb_VCO layer met4 side 2 offset 315.96
        block vsdbabysoc pin REF layer met5 side 1 offset 912.8
        block vsdbabysoc pin VREFH layer met5 side 1 offset 304.2

* report_placement report :
  
          ****************************************
        Report : report_placement
        Design : vsdbabysoc
        Version: T-2022.03-SP5
        Date   : Mon Aug  5 13:42:44 2024
        ****************************************
          ==================
          Note: Including violations of fixed cells or between fixed pairs of cells. 
                To ignore violations of / between fixed cells, enable -ignore_fixed. 
          ==================
        
          Wire length report (all)
          ==================
          wire length in design vsdbabysoc/post_placement: 100152.658 microns.
          wire length in design vsdbabysoc/post_placement (see through blk pins): 100152.658 microns.
        
          Physical hierarchy violations report
          ====================================
          Violations in design vsdbabysoc/post_placement:
             0 cells have placement violation.
        
          Voltage area violations report
          ====================================
          Voltage area placement violations in design vsdbabysoc/post_placement:
             0 cells placed outside the voltage area which they belong to.
        
        Information: Default error view vsdbabysoc_dpplace.err is created in GUI error browser. (DPP-054)
        1

* Timing report showing slack met with 0.52 value (`/home/subhasis/VSDBabySoC/scripts/PD_flow/rpts_icc2/timing_estimation/vsdbabysoc.post_estimated_timing.rpt` :

        ****************************************
        Report : timing
                -path_type full
                -delay_type max
                -max_paths 1
                -report_by design
        Design : vsdbabysoc
        Version: T-2022.03-SP5
        Date   : Fri Jul 19 12:52:20 2024
        ****************************************
        
          Startpoint: core/CPU_is_addi_a3_reg (rising edge-triggered flip-flop clocked by clk)
          Endpoint: core/CPU_Xreg_value_a4_reg[10][31] (rising edge-triggered flip-flop clocked by clk)
          Mode: func1
          Corner: estimated_corner
          Scenario: func1::estimated_corner
          Path Group: clk
          Path Type: max
        
          Point                                            Incr      Path       Delta Incr     Analysis
          ----------------------------------------------------------------------------------------------------
          clock clk (rise edge)                            0.00      0.00
          clock network delay (ideal)                      0.00      0.00
        
          core/CPU_is_addi_a3_reg/CLK (sky130_fd_sc_hd__dfxtp_1)
                                                           0.00      0.00 r      0.00
          core/CPU_is_addi_a3_reg/Q (sky130_fd_sc_hd__dfxtp_1)
                                                           0.30      0.30 f      0.00        Size: None
          core/U474/Y (sky130_fd_sc_hd__nor2_1)            0.32      0.62 r      0.18        Size: None
          core/U476/Y (sky130_fd_sc_hd__nand2_1)           0.43      1.04 f      0.31        Size: None
          core/U51/Y (sky130_fd_sc_hd__nand2_2)            0.22 e    1.26 r     -0.29        Size: sky130_fd_sc_hd__nand2_8
          core/U50/X (sky130_fd_sc_hd__and2_0)             0.18 e    1.44 r     -0.06        Size: sky130_fd_sc_hd__and2_4
          core/U572/X (sky130_fd_sc_hd__xor2_1)            0.20 e    1.64 f      0.12        Size: sky130_fd_sc_hd__xor2_4
          core/U48/X (sky130_fd_sc_hd__or2_0)              0.28 e    1.93 f     -0.01        Size: sky130_fd_sc_hd__or2_4
          core/U574/Y (sky130_fd_sc_hd__a21oi_1)           0.20 e    2.13 r     -0.04        Size: sky130_fd_sc_hd__a21oi_4
          core/U576/Y (sky130_fd_sc_hd__o21ai_1)           0.08 e    2.21 f     -0.06        Size: sky130_fd_sc_hd__o21ai_4
          core/U581/Y (sky130_fd_sc_hd__a21oi_1)           0.18 e    2.39 r     -0.05        Size: sky130_fd_sc_hd__a21oi_4
          core/U583/Y (sky130_fd_sc_hd__o21ai_1)           0.06 e    2.45 f     -0.18        Size: sky130_fd_sc_hd__o21ai_4
          core/U587/Y (sky130_fd_sc_hd__a21oi_1)           0.18 e    2.63 r     -0.10        Size: sky130_fd_sc_hd__a21oi_4
          core/U589/Y (sky130_fd_sc_hd__o21ai_1)           0.07 e    2.70 f     -0.06        Size: sky130_fd_sc_hd__o21ai_4
          core/U344/Y (sky130_fd_sc_hd__a21oi_1)           0.18 e    2.88 r     -0.05        Size: sky130_fd_sc_hd__a21oi_4
          core/U213/Y (sky130_fd_sc_hd__o21ai_1)           0.07 e    2.96 f     -0.06        Size: sky130_fd_sc_hd__o21ai_4
          core/U343/Y (sky130_fd_sc_hd__a21oi_1)           0.18 e    3.14 r     -0.04        Size: sky130_fd_sc_hd__a21oi_4
          core/U210/Y (sky130_fd_sc_hd__o21ai_1)           0.08 e    3.21 f     -0.06        Size: sky130_fd_sc_hd__o21ai_4
          core/U342/Y (sky130_fd_sc_hd__a21oi_1)           0.18 e    3.39 r     -0.05        Size: sky130_fd_sc_hd__a21oi_4
          core/U209/Y (sky130_fd_sc_hd__o21ai_1)           0.07 e    3.47 f     -0.06        Size: sky130_fd_sc_hd__o21ai_4
          core/U341/Y (sky130_fd_sc_hd__a21oi_1)           0.19 e    3.66 r     -0.06        Size: sky130_fd_sc_hd__a21oi_4
          core/U215/Y (sky130_fd_sc_hd__o21ai_1)           0.06 e    3.72 f     -0.08        Size: sky130_fd_sc_hd__o21ai_4
          core/U96/X (sky130_fd_sc_hd__a21o_1)             0.18 e    3.90 f     -0.00        Size: None
          core/U942/COUT (sky130_fd_sc_hd__fa_1)           0.41      4.31 f      0.00        Size: None
          core/U94/X (sky130_fd_sc_hd__a21o_1)             0.17 e    4.48 f     -0.02        Size: None
          core/U905/COUT (sky130_fd_sc_hd__fa_1)           0.26 e    4.74 f     -0.12        Size: sky130_fd_sc_hd__fah_1
          core/U887/COUT (sky130_fd_sc_hd__fa_1)           0.27 e    5.01 f     -0.13        Size: sky130_fd_sc_hd__fah_1
          core/U1370/COUT (sky130_fd_sc_hd__fa_1)          0.26 e    5.27 f     -0.14        Size: sky130_fd_sc_hd__fah_1
          core/U36/COUT (sky130_fd_sc_hd__fa_2)            0.30 e    5.57 f     -0.07        Size: sky130_fd_sc_hd__fah_1
          core/U87/Y (sky130_fd_sc_hd__clkinv_1)           0.06      5.63 r      0.01        Size: None
          core/U613/Y (sky130_fd_sc_hd__o21ai_1)           0.06 e    5.70 f     -0.01        Size: sky130_fd_sc_hd__o21ai_2
          core/U352/COUT (sky130_fd_sc_hd__fa_1)           0.28 e    5.98 f     -0.12        Size: sky130_fd_sc_hd__fah_1
          core/U348/COUT (sky130_fd_sc_hd__fa_1)           0.40      6.39 f     -0.00        Size: None
          core/U35/COUT (sky130_fd_sc_hd__fa_1)            0.39      6.78 f     -0.00        Size: None
          core/U33/COUT (sky130_fd_sc_hd__fa_1)            0.42      7.20 f     -0.00        Size: None
          core/U81/X (sky130_fd_sc_hd__a21o_1)             0.18 e    7.38 f     -0.01        Size: None
          core/U347/COUT (sky130_fd_sc_hd__fa_1)           0.38      7.76 f      0.00        Size: None
          core/U351/COUT (sky130_fd_sc_hd__fa_1)           0.39      8.15 f     -0.00        Size: None
          core/U617/X (sky130_fd_sc_hd__xor2_1)            0.51      8.66 r      0.19        Size: None
          core/U618/Y (sky130_fd_sc_hd__nand2_2)           0.13 e    8.79 f     -0.16        Size: sky130_fd_sc_hd__nand2_8
          core/U647/Y (sky130_fd_sc_hd__o22ai_1)           0.12 e    8.91 r     -0.15        Size: sky130_fd_sc_hd__o22ai_2
          core/CPU_Xreg_value_a4_reg[10][31]/D (sky130_fd_sc_hd__dfxtp_1)
                                                           0.00 e    8.91 r      0.00        Buff: Short net
          data arrival time                                          8.91       -1.41        Delta arrival
        
          clock clk (rise edge)                           10.00     10.00
          clock network delay (ideal)                      0.00     10.00
          core/CPU_Xreg_value_a4_reg[10][31]/CLK (sky130_fd_sc_hd__dfxtp_1)
                                                           0.00     10.00 r      0.00
          clock uncertainty                               -0.50      9.50
          library setup time                              -0.07      9.43
          data required time                                         9.43
          ----------------------------------------------------------------------------------------------------
          data required time                                         9.43
          data arrival time                                         -8.91
          ----------------------------------------------------------------------------------------------------
          slack (MET)                                                0.52
        
        
        1
post-placement qor report (`/home/subhasis/VSDBabySoC/scripts/PD_flow/rpts_icc2/timing_estimation/vsdbabysoc.post_estimated_timing.qor`) :

    ****************************************
    Report : qor
    Design : vsdbabysoc
    Version: T-2022.03-SP5
    Date   : Fri Jul 19 12:52:20 2024
    ****************************************
    
    
    Scenario           'func1::estimated_corner'
    Timing Path Group  'default'
    ----------------------------------------
    Levels of Logic:                      1
    Critical Path Length:              0.19
    Critical Path Slack:               9.81
    Critical Path Clk Period:            --
    Total Negative Slack:              0.00
    No. of Violating Paths:               0
    ----------------------------------------
    
    Scenario           'func1::estimated_corner'
    Timing Path Group  'clk'
    ----------------------------------------
    Levels of Logic:                     39
    Critical Path Length:              8.91
    Critical Path Slack:               0.52
    Critical Path Clk Period:         10.00
    Total Negative Slack:              0.00
    No. of Violating Paths:               0
    ----------------------------------------
    
    
    Cell Count
    ----------------------------------------
    Hierarchical Cell Count:              1
    Hierarchical Port Count:             14
    Leaf Cell Count:                   2743
    Buf/Inv Cell Count:                 578
    Buf Cell Count:                       2
    Inv Cell Count:                     576
    CT Buf/Inv Cell Count:                0
    Combinational Cell Count:          2067
       Single-bit Isolation Cell Count:                        0
       Multi-bit Isolation Cell Count:                         0
       Isolation Cell Banking Ratio:                           0.00%
       Single-bit Level Shifter Cell Count:                    0
       Multi-bit Level Shifter Cell Count:                     0
       Level Shifter Cell Banking Ratio:                       0.00%
       Single-bit ELS Cell Count:                              0
       Multi-bit ELS Cell Count:                               0
       ELS Cell Banking Ratio:                                 0.00%
    Sequential Cell Count:              676
       Integrated Clock-Gating Cell Count:                     0
       Sequential Macro Cell Count:                            0
       Single-bit Sequential Cell Count:                       676
       Multi-bit Sequential Cell Count:                        0
       Sequential Cell Banking Ratio:                          0.00%
       BitsPerflop:                                            1.00
    Macro Count:                          2
    ----------------------------------------
    
    
    Area
    ----------------------------------------
    Combinational Area:            11407.19
    Noncombinational Area:         13532.98
    Buf/Inv Area:                   2169.58
    Total Buffer Area:                 7.51
    Total Inverter Area:            2162.07
    Macro/Black Box Area:         671652.37
    Net Area:                             0
    Net XLength:                   50626.57
    Net YLength:                   49587.19
    ----------------------------------------
    Cell Area (netlist):                         696592.54
    Cell Area (netlist and physical only):       696592.55
    Net Length:                   100213.75
    
    
    Design Rules
    ----------------------------------------
    Total Number of Nets:              2993
    Nets with Violations:               434
    Max Trans Violations:                30
    Max Cap Violations:                 434
    ----------------------------------------
    
    1

</details>

<details>

<summary>Day 15 - CTS</summary>

Clock Tree Synthesis (CTS) is a critical process in VLSI design, aimed at ensuring that the clock signal is efficiently distributed across all sequential elements in a circuit. This process is essential for maintaining timing integrity, minimizing power consumption, and optimizing performance.

## Overview of Clock Tree Synthesis

CTS involves connecting the clock signal from the clock port to the clock pins of sequential cells while minimizing insertion delay and balancing skew. The clock network is typically categorized as a high fanout net, which requires special handling due to its significant power consumption—often accounting for 30-40% of total chip power—and its susceptibility to electromigration (EM) effects.

### Key Objectives of CTS

1. **Minimize Insertion Delay**: This is crucial for ensuring that the clock signal reaches all components in a timely manner, thus maintaining the overall performance of the design.
   
2. **Balance Skew**: Skew refers to the difference in arrival times of the clock signal at different sequential elements. Balancing skew is vital to ensure synchronous operation of the circuit.

3. **Power Optimization**: Since the clock network consumes a substantial amount of power, optimizing its design can lead to significant energy savings.

## Steps in Clock Tree Synthesis

The CTS process typically includes the following steps:

1. **Preparation**: This involves checking the legality of the design, ensuring power connections are correct, and verifying that the timing quality of results (QoR) is acceptable.

2. **Clustering**: Grouping sink pins based on their geometric locations to facilitate better skew management.

3. **Buffer Insertion**: Automatically inserting buffers and inverters along the clock paths to manage load and reduce insertion delay.

4. **Balancing**: Using clock buffers and inverters to achieve a balanced clock distribution across the design.

5. **Post-Conditioning**: Final adjustments to ensure that all design rules are met and that the clock tree operates within specified parameters for skew and insertion delay.

### Types of Clock Tree Structures

Several structures can be utilized for building the clock tree, including:

- **H-Tree Structure**: A balanced tree structure that minimizes skew.
- **X-Tree Structure**: Similar to the H-tree but optimized for different geometries.
- **Geometric Matching Algorithm (GMA)**: A method for optimizing the layout of the clock tree.
- **Pi Tree Structure**: A structure that balances loads effectively.
- **Fishbone Structure**: A more complex design that can handle varying loads and distances.

## Inputs and Outputs of CTS

### Inputs Required for CTS

- **Placement Database (DB)**: Contains the netlist after placement, including various technology files and specifications.
- **Clock Tree Specification File**: Defines the requirements and constraints for the clock tree.
- **Library Files**: Include information on clock buffers and inverters used in the design.

### Outputs of CTS

After the CTS process, the outputs typically include:

- A netlist that reflects the clock tree configuration.
- Timing reports detailing setup and hold times.
- Skew and latency reports to assess clock performance.

## Quality Checks Post-CTS

After completing the CTS, several checks are necessary to ensure the clock tree meets design goals:

- **Insertion Delay**: Must meet target values.
- **Skew Balancing**: Should be within acceptable limits.
- **Signal Integrity**: Ensuring minimal crosstalk and other noise effects.
- **Power Consumption**: Evaluating the clock tree's power usage to ensure it aligns with design specifications.

In summary, Clock Tree Synthesis is a fundamental aspect of VLSI design that directly impacts the performance, power efficiency, and reliability of integrated circuits. Proper execution of CTS ensures that the clock signal is effectively distributed, enabling synchronous operation of all components within the design.

Citations:
[1] https://vlsitalks.com/physical-design/cts/
[2] https://anysilicon.com/clock-tree-synthesis/
[3] https://vlsitutor.com/nots/clock-tree-synthesis/
[4] https://signoffsemiconductors.com/clock-tree-synthesis-1/
[5] https://www.physicaldesign4u.com/2020/02/clock-tree-synthesis.html

#### Lab - CTS of VSDBabySoC :

* `set_clock_tree_options :

       Specifies settings like target skew or latency  for  clocks,  exception
       duplication across modes or fanout-based nondefault routing rule limit.

       If target skew is specified, clock tree synthesis engine minimizes skew
       to meet the specified target.  After this target is met, the  optimiza-
       tion  concentrates more on other QoR goals, such as insertion delay and
       area.

       If target latency is specified, clock tree synthesis  engine  minimizes
       latency  to  meet  the specified target.  After this target is met, the
       optimization concentrates more on other QoR goals,  such  as  skew  and
       area.   If  the insertion delay of this initial optimized clock tree is
       smaller than the specified value, the clock tree synthesis engine  adds
       a chain of cells from the reference list as needed to meet this delay.

       If  fanout-based  nondefault routing rule is specified, clock tree syn-
       thesis engine applies root or internal rules based on  the  limit  set-
       ting.   The  sink  nondefault  routing  rule  does not get affected and
       remains as sink nondefault  routing  rule.   Small  net  (for  example,
       bounding  box  <  10 um) still has internal rules even if its fanout is
       larger than limit.

       To  report  target   skew   or   latency   constraint   settings,   use
       report_clock_tree_options.

       To     remove    target    skew    or    latency    constraints,    use
       remove_clock_tree_options.

       To  report  fanout-based  nondefault   routing   rule   settings,   use
       report_clock_tree_options.

       To   remove   fanout-based   nondefault   routing  rule  settings,  use
       remove_clock_tree_options.

* Default clock tree options in ICC2 :

![image](https://github.com/user-attachments/assets/8611c11e-e13d-487b-806b-712160fa6182)

* `clock_opt` :

        The default behavior of this command is as follows:
               1. Synthesizes and optimizes the clock trees.
        
               2. Completes the detail routing of the clock trees.
        
               3. Further optimizes the design for timing,electrical  DRC  violations,
                 area, power, and routability, based on actual propagated clock laten-
                 cies, and legalizes the design placement.
        
               The final_opto stage begins  with  optimization,  followed  by  timing-
               driven  placement and legalization.  This stage then runs a full global
               route, and follows that with extensive global route-based optimization.
               The  global  route-based optimization performs incremental legalization
               and routing patch-up. The output of the final_opto stage  is  a  design
               having  all  signal nets global routed and timing based on actual rout-
               ing. The subsequent signal routing  flow  (route_auto,route_global,  or
               route_group)  will automatically skip global routing. It is recommended
               that the user does not change global routing / shapes  after  clock_opt
               in order to avoid errors during subsequent track and detailed routing.
        
               The final_opto stage may be executed once only in the flow.

* `report_clock_timing -type summary` :

        ****************************************
        Report : clock timing
                -type summary
        Design : vsdbabysoc
        Version: T-2022.03-SP5
        Date   : Mon Aug  5 14:04:56 2024
        ****************************************
        
          Mode: func1
          Clock: clk
                                                                                         Corner
        ---------------------------------------------------------------------------------------------------
          Maximum setup launch latency:
              core/CPU_Xreg_value_a4_reg[16][31]/CLK                   1.05       rp-+      func1
        
          Minimum setup capture latency:
              core/CPU_Xreg_value_a4_reg[26][11]/CLK                   0.48       rp-+      func1
        
          Minimum hold launch latency:
              core/CPU_Xreg_value_a4_reg[26][11]/CLK                   0.48       rp-+      func1
        
          Maximum hold capture latency:
              core/CPU_Xreg_value_a4_reg[16][31]/CLK                   1.05       rp-+      func1
        
          Maximum active transition:
              core/CPU_Xreg_value_a4_reg[11][13]/CLK                   0.85       rp-+      func1
        
          Minimum active transition:
              core/CPU_Xreg_value_a4_reg[26][17]/CLK                   0.17       rp-+      func1
        
          Maximum setup skew:
              core/CPU_src2_value_a3_reg[0]/CLK                                   rp-+      func1
              core/CPU_Xreg_value_a4_reg[26][11]/CLK                   0.56       rp-+      func1
        
          Maximum hold skew:
              core/CPU_Xreg_value_a4_reg[26][11]/CLK                              rp-+      func1
              core/CPU_src1_value_a3_reg[11]/CLK                       0.52       rp-+      func1
        
* `report_clock_timing -type skew` :
  
        ****************************************
        Report : clock timing
                -type skew
                -nworst 1
                -setup
        Design : vsdbabysoc
        Version: T-2022.03-SP5
        Date   : Mon Aug  5 14:06:58 2024
        ****************************************
        
          Mode: func1
          Clock: clk
        
          Clock Pin                                          Latency      Skew             Corner
        ---------------------------------------------------------------------------------------------------
          core/CPU_src2_value_a3_reg[0]/CLK                     1.04              rp-+      func1
          core/CPU_Xreg_value_a4_reg[26][21]/CLK                0.48      0.56    rp-+      func1
        
        ---------------------------------------------------------------------------------------------------

* `report_clock_timing -type latency` :
  
          ****************************************
        Report : clock timing
                -type latency
                -launch
                -nworst 1
                -setup
        Design : vsdbabysoc
        Version: T-2022.03-SP5
        Date   : Mon Aug  5 14:08:45 2024
        ****************************************
        
          Mode: func1
          Clock: clk
        
                                                         --- Latency ---
          Clock Pin                             Trans   Source   Offset  Network    Total            Corner
        ---------------------------------------------------------------------------------------------------
          core/CPU_Xreg_value_a4_reg[16][25]/CLK
                                                 0.28     0.00       --     1.05     1.05 rp-+        func1
        ---------------------------------------------------------------------------------------------------

* `report_clock_timing -type transition` :

        ****************************************
        Report : clock timing
                -type transition
                -launch
                -nworst 1
                -setup
        Design : vsdbabysoc
        Version: T-2022.03-SP5
        Date   : Mon Aug  5 14:10:05 2024
        ****************************************
        
          Mode: func1
          Clock: clk
        
                                                    --- Latency ---
          Clock Pin                            Source  Network    Total    Trans           Corner
        ---------------------------------------------------------------------------------------------------
          core/CPU_Xreg_value_a4_reg[11][13]/CLK
                                                 0.00     0.68     0.68     0.85  rp-+      func1
        ---------------------------------------------------------------------------------------------------
  

</details>

<details>

<summary>Day 16 - Routing</summary>

Routing is a crucial stage in the VLSI design flow that creates physical connections between signal pins by following design rules. The main goals of routing are to minimize total wire length and vias, complete routing within the design area, meet timing constraints, and avoid design rule violations.

## Types of Routing

There are three main types of routing:

1. **Pre-routing** (also known as power routing) which is done during power planning.
2. **Clock routing** performed while building the clock tree in the clock tree synthesis (CTS) stage.
3. **Signal routing** done after CTS to connect all signal pins.

## Routing Flow

The routing flow consists of four main stages:

1. **Global Routing**: Divides the core area into global cells (gcells) and finds the shortest path for each net using algorithms like maze routing and Steiner tree. It assigns nets to specific gcells but does not define actual tracks.

2. **Track Assignment**: Assigns actual metal layers to global routes while fixing some design rule violations. However, many DRC, signal integrity, and timing violations still remain.

3. **Detailed Routing**: Completes the actual metal and via connections between pins. It fixes all remaining violations through multiple iterations. The block is divided into switch boxes (Sboxes) for routing.

4. **Search and Repair**: Performed after the first detailed routing iteration to locate and fix any remaining shorts or spacing violations[2][3].

## Routing Constraints

Key routing constraints include:

* Design rule constraints related to manufacturing 
* Performance constraints to meet timing
* Routing density constraints to avoid congestion
* Constraints on off-grid routing
* Blocked routing regions

## Routing Outputs

The main outputs of routing are:

* Geometric layout of all nets in GDS format
* SPEF file for parasitics 
* Updated SDC file with routed timing

In summary, routing is a critical step that completes the physical connections in the design while meeting various constraints. Efficient routing is essential for manufacturability and performance closure in modern VLSI designs.

Citations:
[1] https://vlsitalks.com/physical-design/routing/
[2] https://www.vlsi4freshers.com/2020/01/routing.html
[3] http://vlsibegin.blogspot.com/p/routing.html
[4] https://www.vlsi-backend-adventure.com/routing.html
[5] https://signoffsemiconductors.com/routing/

#### Lab - Routing of VSDBabySoC :

* Min & Max Routing Layer,set up in icc2_common_setup.tcl & top.tcl :

![image](https://github.com/user-attachments/assets/02742271-adce-41b7-9fec-50d35c954576)

* `check_routes` : Verifies  and  reports routing design rule checking (DRC) violations, net opens, antenna  rule  violations,  voltage-area  rule violations,  and via conversion rates.  DRCs, antenna violations
                   and voltage-area rule violations can be viewed in error browser. Open net information cannot be seen in error browser.

          DRC-SUMMARY:
        	@@@@@@@ TOTAL VIOLATIONS =	27
        	Diff net spacing : 2
        	Diff net via-cut spacing : 6
        	Less than minimum area : 2
        	Less than minimum width : 1
        	Same net spacing : 1
        	Short : 15
        
        
        Total Wire Length =                    126709 micron
        Total Number of Contacts =             35934
        Total Number of Wires =                30212
        Total Number of PtConns =              325
        Total Number of Routed Wires =       30212
        Total Routed Wire Length =           126577 micron
        Total Number of Routed Contacts =       35934
        	Layer          li1 :         61 micron
        	Layer         met1 :      20220 micron
        	Layer         met2 :      52814 micron
        	Layer         met3 :      44357 micron
        	Layer         met4 :       8224 micron
        	Layer         met5 :       1034 micron
        	Via        M4M5_PR :        146
        	Via        M3M4_PR :       1145
        	Via      M3M4_PR_C :          1
        	Via        M2M3_PR :       6822
        	Via   M2M3_PR(rot) :          9
        	Via        M1M2_PR :      14056
        	Via   M1M2_PR(rot) :         14
        	Via      M1M2_PR_C :          1
        	Via        L1M1_PR :      11817
        	Via   L1M1_PR(rot) :       1864
        	Via      L1M1_PR_C :         59

* Post_route qor report :

          ****************************************
        Report : qor
        Design : vsdbabysoc
        Version: T-2022.03-SP5
        Date   : Mon Aug  5 14:49:56 2024
        ****************************************
        
        
        Scenario           'func1'
        Timing Path Group  'default'
        ----------------------------------------
        Levels of Logic:                      1
        Critical Path Length:              0.68
        Critical Path Slack:               9.32
        Critical Path Clk Period:            --
        Total Negative Slack:              0.00
        No. of Violating Paths:               0
        ----------------------------------------
        
        Scenario           'func1'
        Timing Path Group  'clk'
        ----------------------------------------
        Levels of Logic:                     55
        Critical Path Length:              9.71
        Critical Path Slack:               0.09
        Critical Path Clk Period:         10.00
        Total Negative Slack:              0.00
        No. of Violating Paths:               0
        Worst Hold Violation:              0.00
        Total Hold Violation:              0.00
        No. of Hold Violations:               0
        ----------------------------------------
        
        
        Cell Count
        ----------------------------------------
        Hierarchical Cell Count:              1
        Hierarchical Port Count:             14
        Leaf Cell Count:                   4758
        Buf/Inv Cell Count:                2594
        Buf Cell Count:                    2040
        Inv Cell Count:                     554
        CT Buf/Inv Cell Count:                0
        Combinational Cell Count:          4082
           Single-bit Isolation Cell Count:                        0
           Multi-bit Isolation Cell Count:                         0
           Isolation Cell Banking Ratio:                           0.00%
           Single-bit Level Shifter Cell Count:                    0
           Multi-bit Level Shifter Cell Count:                     0
           Level Shifter Cell Banking Ratio:                       0.00%
           Single-bit ELS Cell Count:                              0
           Multi-bit ELS Cell Count:                               0
           ELS Cell Banking Ratio:                                 0.00%
        Sequential Cell Count:              676
           Integrated Clock-Gating Cell Count:                     0
           Sequential Macro Cell Count:                            0
           Single-bit Sequential Cell Count:                       676
           Multi-bit Sequential Cell Count:                        0
           Sequential Cell Banking Ratio:                          0.00%
           BitsPerflop:                                            1.00
        Macro Count:                          2
        ----------------------------------------
        
        
        Area
        ----------------------------------------
        Combinational Area:            20504.67
        Noncombinational Area:         15955.30
        Buf/Inv Area:                  11059.36
        Total Buffer Area:              8533.18
        Total Inverter Area:            2526.17
        Macro/Black Box Area:         671652.37
        Net Area:                             0
        Net XLength:                   66134.05
        Net YLength:                   62157.71
        ----------------------------------------
        Cell Area (netlist):                         708112.34
        Cell Area (netlist and physical only):      1536076.43
        Net Length:                   128291.75
        
        
        Design Rules
        ----------------------------------------
        Total Number of Nets:              4780
        Nets with Violations:               390
        Max Trans Violations:                 0
        Max Cap Violations:                 390
        ----------------------------------------
        
        1


</details>

<details>
    
<summary>Day 17 - STA using Prime Time</summary>

After routing is completed, in icc2_shell, we can extract parasitics information in .SPEF format by using following command :

`write_parasitics -corner func1 -output /home/subhasis/VSDBabySoC/output/vsdbabysoc_parasitics`


.SPEF file :

![image](https://github.com/user-attachments/assets/3129aa22-b34e-472d-be4e-b56dda3b9d50)

In ICC2_shell, we can also write out the post_route netlist :

`write_verilog /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route_net.v`

    
* Now we can use Prime Time tool for timing analysis using following script present at `/home/subhasis/VSDBabySoC/scripts/prime_time_sta.tcl` :

    
        set_app_var link_path [list * /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__tt_025C_1v80.db /home/subhasis/VSDBabySoC/src/lib/avsdpll.db /home/subhasis/VSDBabySoC/src/lib/avsddac.db]
        
        read_verilog /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route_net.v
        current_design vsdbabysoc
        link_design
        
        #set_min_library -min_version /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__ff_n40C_1v95.db /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__ss_n40C_1v28.db
        
        read_sdc /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route.sdc
        read_parasitics /home/subhasis/VSDBabySoC/output/vsdbabysoc_parasitics.temp1_25.spef
        
        report_analysis_coverage > /home/subhasis/VSDBabySoC/output/reports/prime_time_analysis_coverage.rpt
        report_constraint -all_violators > /home/subhasis/VSDBabySoC/output/reports/prime_time_constraint.rpt
        report_timing -delay_type max -capacitance -input_pins -nets -transition_time -nosplit -significant_digits 4 > /home/subhasis/VSDBabySoC/output/reports/prime_time_setup_timing.rpt
        report_timing -delay_type min -capacitance -input_pins -nets -transition_time -nosplit -significant_digits 4 > /home/subhasis/VSDBabySoC/output/reports/prime_time_hold_timing.rpt

* We can find Prime Time analysis reports in this directory `/home/subhasis/VSDBabySoC/output/reports/`

        ****************************************
        Report : analysis_coverage
        Design : vsdbabysoc
        Version: T-2022.03-SP5-4
        Date   : Tue Jul 16 14:05:34 2024
        ****************************************
        
        Type of Check         Total              Met         Violated         Untested
        --------------------------------------------------------------------------------
        setup                   676       662 ( 98%)        13 (  2%)         1 (  0%)
        hold                    676       671 ( 99%)         4 (  1%)         1 (  0%)
        min_pulse_width        1352      1352 (100%)         0 (  0%)         0 (  0%)
        --------------------------------------------------------------------------------
        All Checks             2704      2685 ( 99%)        17 (  1%)         2 (  0%)

        ****************************************
        Report : timing
        	-path_type full
        	-delay_type max
        	-input_pins
        	-nets
        	-max_paths 1
        	-transition_time
        	-capacitance
        	-sort_by slack
        Design : vsdbabysoc
        Version: T-2022.03-SP5-4
        Date   : Tue Jul 16 14:05:35 2024
        ****************************************
        
        
          Startpoint: core/CPU_is_add_a3_reg
                       (rising edge-triggered flip-flop clocked by clk)
          Endpoint: core/CPU_Xreg_value_a4_reg[27][31]
                       (rising edge-triggered flip-flop clocked by clk)
          Last common pin: pll/CLK
          Path Group: clk
          Path Type: max
        
          Point                                                          Fanout    Cap      Trans       Incr       Path
          ----------------------------------------------------------------------------------------------------------------
          clock clk (rise edge)                                                                       0.0000     0.0000
          clock network delay (propagated)                                                            0.4597     0.4597
          core/CPU_is_add_a3_reg/CLK (sky130_fd_sc_hd__dfxtp_1)                            0.5639     0.0000     0.4597 r
          core/CPU_is_add_a3_reg/Q (sky130_fd_sc_hd__dfxtp_1)                              0.0368     0.4277 &   0.8875 f
          core/CPU_is_add_a3 (net)                                          2   0.0051 
          core/U474/A (sky130_fd_sc_hd__nor2_1)                                            0.0369     0.0008 &   0.8883 f
          core/U474/Y (sky130_fd_sc_hd__nor2_1)                                            0.1344     0.1348 &   1.0230 r
          core/n144 (net)                                                   2   0.0062 
          core/U476/B (sky130_fd_sc_hd__nand2_1)                                           0.1344     0.0009 &   1.0240 r
          core/U476/Y (sky130_fd_sc_hd__nand2_1)                                           0.1141     0.1318 &   1.1558 f
          core/n147 (net)                                                   2   0.0140 
          core/U51/A (sky130_fd_sc_hd__nand2_2)                                            0.1143     0.0031 &   1.1590 f
          core/U51/Y (sky130_fd_sc_hd__nand2_2)                                            0.2259     0.2052 &   1.3642 r
          core/n206 (net)                                                   8   0.0402 
          core/ctmTdsLR_1_764/B1 (sky130_fd_sc_hd__a22oi_1)                                0.2266     0.0074 &   1.3716 r
          core/ctmTdsLR_1_764/Y (sky130_fd_sc_hd__a22oi_1)                                 0.1205     0.1179 &   1.4895 f
          core/tmp_net1 (net)                                               2   0.0053 
          core/ctmTdsLR_2_765/A1_N (sky130_fd_sc_hd__o2bb2ai_1)                            0.1205     0.0008 &   1.4904 f
          core/ctmTdsLR_2_765/Y (sky130_fd_sc_hd__o2bb2ai_1)                               0.1105     0.1830 &   1.6733 f
          core/n210 (net)                                                   2   0.0080 
          core/ctmTdsLR_1_822/A2 (sky130_fd_sc_hd__a21boi_1)                               0.1106     0.0012 &   1.6746 f
          core/ctmTdsLR_1_822/Y (sky130_fd_sc_hd__a21boi_1)                                0.2390     0.2545 &   1.9291 r
          core/n809 (net)                                                   2   0.0096 
          core/U571/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.2396     0.0020 &   1.9311 r
          core/U571/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1057     0.1431 &   2.0742 f
          core/n791 (net)                                                   2   0.0106 
          core/ctmTdsLR_1_833/A1 (sky130_fd_sc_hd__a21boi_2)                               0.1059     0.0024 &   2.0766 f
          core/ctmTdsLR_1_833/Y (sky130_fd_sc_hd__a21boi_2)                                0.1494     0.1832 &   2.2598 r
          core/n774 (net)                                                   2   0.0092 
          core/U576/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.1495     0.0020 &   2.2618 r
          core/U576/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1085     0.1235 &   2.3853 f
          core/n755 (net)                                                   2   0.0110 
          core/ctmTdsLR_1_844/A1 (sky130_fd_sc_hd__a21boi_2)                               0.1088     0.0027 &   2.3880 f
          core/ctmTdsLR_1_844/Y (sky130_fd_sc_hd__a21boi_2)                                0.1395     0.1792 &   2.5671 r
          core/n740 (net)                                                   2   0.0085 
          core/U583/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.1395     0.0013 &   2.5685 r
          core/U583/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1602     0.1565 &   2.7250 f
          core/n722 (net)                                                   2   0.0178 
          core/ctmTdsLR_1_845/A1 (sky130_fd_sc_hd__a21boi_2)                               0.1608     0.0040 &   2.7290 f
          core/ctmTdsLR_1_845/Y (sky130_fd_sc_hd__a21boi_2)                                0.1638     0.2151 &   2.9441 r
          core/n707 (net)                                                   2   0.0105 
          core/U589/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.1644     0.0022 &   2.9462 r
          core/U589/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1096     0.1280 &   3.0743 f
          core/n689 (net)                                                   2   0.0112 
          core/ctmTdsLR_1_1906/A1 (sky130_fd_sc_hd__a21boi_2)                              0.1099     0.0026 &   3.0769 f
          core/ctmTdsLR_1_1906/Y (sky130_fd_sc_hd__a21boi_2)                               0.1429     0.1823 &   3.2591 r
          core/n674 (net)                                                   2   0.0089 
          core/U213/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.1429     0.0014 &   3.2605 r
          core/U213/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1443     0.1470 &   3.4075 f
          core/n656 (net)                                                   2   0.0158 
          core/ctmTdsLR_1_846/A1 (sky130_fd_sc_hd__a21boi_2)                               0.1448     0.0036 &   3.4111 f
          core/ctmTdsLR_1_846/Y (sky130_fd_sc_hd__a21boi_2)                                0.1389     0.1925 &   3.6036 r
          core/n641 (net)                                                   2   0.0085 
          core/U210/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.1390     0.0013 &   3.6049 r
          core/U210/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1201     0.1272 &   3.7320 f
          core/n623 (net)                                                   2   0.0122 
          core/ctmTdsLR_1_847/A1 (sky130_fd_sc_hd__a21boi_2)                               0.1205     0.0029 &   3.7349 f
          core/ctmTdsLR_1_847/Y (sky130_fd_sc_hd__a21boi_2)                                0.1961     0.2246 &   3.9595 r
          core/n608 (net)                                                   2   0.0135 
          core/U209/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.1966     0.0029 &   3.9624 r
          core/U209/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1017     0.1300 &   4.0924 f
          core/n590 (net)                                                   2   0.0101 
          core/ctmTdsLR_1_848/A1 (sky130_fd_sc_hd__a21boi_1)                               0.1018     0.0021 &   4.0945 f
          core/ctmTdsLR_1_848/Y (sky130_fd_sc_hd__a21boi_1)                                0.2232     0.2225 &   4.3170 r
          core/n575 (net)                                                   2   0.0090 
          core/U215/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.2233     0.0014 &   4.3184 r
          core/U215/Y (sky130_fd_sc_hd__o21ai_1)                                           0.0866     0.1265 &   4.4448 f
          core/n557 (net)                                                   2   0.0085 
          core/ctmTdsLR_1_849/A (sky130_fd_sc_hd__nand2_1)                                 0.0867     0.0013 &   4.4461 f
          core/ctmTdsLR_1_849/Y (sky130_fd_sc_hd__nand2_1)                                 0.0518     0.0742 &   4.5203 r
          core/tmp_net33 (net)                                              1   0.0033 
          core/ctmTdsLR_2_850/A (sky130_fd_sc_hd__nand2_1)                                 0.0518     0.0006 &   4.5210 r
          core/ctmTdsLR_2_850/Y (sky130_fd_sc_hd__nand2_1)                                 0.0502     0.0604 &   4.5814 f
          core/n541 (net)                                                   1   0.0055 
          core/U942/CIN (sky130_fd_sc_hd__fa_1)                                            0.0502     0.0011 &   4.5825 f
          core/U942/COUT (sky130_fd_sc_hd__fa_1)                                           0.1261     0.4272 &   5.0097 f
          core/n527 (net)                                                   2   0.0130 
          core/ctmTdsLR_1_851/A (sky130_fd_sc_hd__nand2_1)                                 0.1262     0.0026 &   5.0123 f
          core/ctmTdsLR_1_851/Y (sky130_fd_sc_hd__nand2_1)                                 0.0552     0.0907 &   5.1031 r
          core/tmp_net34 (net)                                              1   0.0033 
          core/ctmTdsLR_2_852/A (sky130_fd_sc_hd__nand2_1)                                 0.0552     0.0006 &   5.1037 r
          core/ctmTdsLR_2_852/Y (sky130_fd_sc_hd__nand2_1)                                 0.0498     0.0604 &   5.1640 f
          core/n511 (net)                                                   1   0.0053 
          core/U905/CIN (sky130_fd_sc_hd__fa_1)                                            0.0499     0.0011 &   5.1651 f
          core/U905/COUT (sky130_fd_sc_hd__fa_1)                                           0.0845     0.3760 &   5.5411 f
          core/n497 (net)                                                   1   0.0054 
          core/U887/CIN (sky130_fd_sc_hd__fa_1)                                            0.0845     0.0011 &   5.5422 f
          core/U887/COUT (sky130_fd_sc_hd__fa_1)                                           0.1014     0.4083 &   5.9505 f
          core/n965 (net)                                                   1   0.0079 
          core/U1370/CIN (sky130_fd_sc_hd__fa_1)                                           0.1018     0.0021 &   5.9527 f
          core/U1370/COUT (sky130_fd_sc_hd__fa_1)                                          0.1003     0.4128 &   6.3655 f
          core/n483 (net)                                                   1   0.0077 
          core/U36/CIN (sky130_fd_sc_hd__fa_2)                                             0.1006     0.0021 &   6.3676 f
          core/U36/COUT (sky130_fd_sc_hd__fa_2)                                            0.0891     0.3800 &   6.7476 f
          core/n469 (net)                                                   2   0.0110 
          core/U87/A (sky130_fd_sc_hd__clkinv_1)                                           0.0894     0.0026 &   6.7502 f
          core/U87/Y (sky130_fd_sc_hd__clkinv_1)                                           0.0402     0.0638 &   6.8140 r
          core/n257 (net)                                                   1   0.0041 
          core/U613/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.0403     0.0008 &   6.8148 r
          core/U613/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1148     0.0961 &   6.9109 f
          core/n452 (net)                                                   1   0.0118 
          core/U352/CIN (sky130_fd_sc_hd__fa_1)                                            0.1149     0.0030 &   6.9139 f
          core/U352/COUT (sky130_fd_sc_hd__fa_1)                                           0.0857     0.4009 &   7.3148 f
          core/n438 (net)                                                   1   0.0056 
          core/U348/CIN (sky130_fd_sc_hd__fa_1)                                            0.0857     0.0011 &   7.3159 f
          core/U348/COUT (sky130_fd_sc_hd__fa_1)                                           0.0893     0.3957 &   7.7117 f
          core/n407 (net)                                                   1   0.0062 
          core/U35/CIN (sky130_fd_sc_hd__fa_1)                                             0.0893     0.0012 &   7.7129 f
          core/U35/COUT (sky130_fd_sc_hd__fa_1)                                            0.0924     0.4016 &   8.1144 f
          core/n382 (net)                                                   1   0.0068 
          core/U33/CIN (sky130_fd_sc_hd__fa_1)                                             0.0924     0.0013 &   8.1157 f
          core/U33/COUT (sky130_fd_sc_hd__fa_1)                                            0.1094     0.4222 &   8.5379 f
          core/n357 (net)                                                   2   0.0094 
          core/ctmTdsLR_1_856/A (sky130_fd_sc_hd__nand2_1)                                 0.1096     0.0021 &   8.5400 f
          core/ctmTdsLR_1_856/Y (sky130_fd_sc_hd__nand2_1)                                 0.0517     0.0834 &   8.6234 r
          core/tmp_net36 (net)                                              1   0.0032 
          core/ctmTdsLR_2_857/A (sky130_fd_sc_hd__nand2_1)                                 0.0517     0.0006 &   8.6240 r
          core/ctmTdsLR_2_857/Y (sky130_fd_sc_hd__nand2_1)                                 0.0547     0.0631 &   8.6872 f
          core/n330 (net)                                                   1   0.0061 
          core/U347/CIN (sky130_fd_sc_hd__fa_2)                                            0.0547     0.0012 &   8.6884 f
          core/U347/COUT (sky130_fd_sc_hd__fa_2)                                           0.0720     0.3425 &   9.0309 f
          core/n305 (net)                                                   1   0.0067 
          core/U351/CIN (sky130_fd_sc_hd__fa_1)                                            0.0720     0.0013 &   9.0322 f
          core/U351/COUT (sky130_fd_sc_hd__fa_1)                                           0.0837     0.3826 &   9.4148 f
          core/n262 (net)                                                   1   0.0052 
          core/U617/B (sky130_fd_sc_hd__xor2_1)                                            0.0838     0.0010 &   9.4158 f
          core/U617/X (sky130_fd_sc_hd__xor2_1)                                            0.0708     0.1649 &   9.5808 f
          core/n286 (net)                                                   2   0.0059 
          core/U618/A (sky130_fd_sc_hd__nand2_1)                                           0.0708     0.0009 &   9.5817 f
          core/U618/Y (sky130_fd_sc_hd__nand2_1)                                           0.1544     0.0712 &   9.6528 r
          core/n284 (net)                                                   1   0.0039 
          core/ZBUF_563_inst_414/A (sky130_fd_sc_hd__buf_2)                                0.1544     0.0006 &   9.6535 r
          core/ZBUF_563_inst_414/X (sky130_fd_sc_hd__buf_2)                                0.3414     0.3348 &   9.9883 r
          core/ZBUF_563_0 (net)                                            15   0.0672 
          core/U627/B2 (sky130_fd_sc_hd__o22ai_1)                                          0.3432     0.0144 &  10.0027 r
          core/U627/Y (sky130_fd_sc_hd__o22ai_1)                                           0.2374     0.1121 &  10.1148 f
          core/n3166 (net)                                                  1   0.0027 
          core/CPU_Xreg_value_a4_reg[27][31]/D (sky130_fd_sc_hd__dfxtp_4)                  0.2374     0.0005 &  10.1153 f
          data arrival time                                                                                     10.1153
        
          clock clk (rise edge)                                                                      10.0000    10.0000
          clock network delay (propagated)                                                            0.6327    10.6327
          clock reconvergence pessimism                                                               0.0000    10.6327
          clock uncertainty                                                                          -0.5000    10.1327
          core/CPU_Xreg_value_a4_reg[27][31]/CLK (sky130_fd_sc_hd__dfxtp_4)                                     10.1327 r
          library setup time                                                                         -0.0804    10.0523
          data required time                                                                                    10.0523
          ----------------------------------------------------------------------------------------------------------------
          data required time                                                                                    10.0523
          data arrival time                                                                                    -10.1153
          ----------------------------------------------------------------------------------------------------------------
          slack (VIOLATED)                                                                                      -0.0630
        
        
        1

* As we can observe from above report, there are few cells having high fanout (8/15 etc.). To resolve this issue of high fanout we can use a `set_max_capacitance` constraint during Physical Design flow,which will improve our timing performance.

Rerunning PD flow with `set_max_capacitance 0.015 -data_path [get_clocks clk]` i.e setting `max capacitance` to `15fF` for our design data path.



Prime time reports after PD flow has been run with max_capacitance constraint :

    ****************************************
    Report : analysis_coverage
    Design : vsdbabysoc
    Version: T-2022.03-SP5-4
    Date   : Fri Jul 19 13:58:39 2024
    ****************************************
    
    Type of Check         Total              Met         Violated         Untested
    --------------------------------------------------------------------------------
    setup                   676       675 (100%)         0 (  0%)         1 (  0%)
    hold                    676       675 (100%)         0 (  0%)         1 (  0%)
    min_pulse_width        1352      1352 (100%)         0 (  0%)         0 (  0%)
    --------------------------------------------------------------------------------
    All Checks             2704      2702 (100%)         0 (  0%)         2 (  0%)
    
    1
    
    
       ****************************************
    Report : timing
    	-path_type full
    	-delay_type max
    	-input_pins
    	-nets
    	-max_paths 1
    	-transition_time
    	-capacitance
    	-sort_by slack
    Design : vsdbabysoc
    Version: T-2022.03-SP5-4
    Date   : Fri Jul 19 13:58:39 2024
    ****************************************
    
    
      Startpoint: core/CPU_is_addi_a3_reg
                   (rising edge-triggered flip-flop clocked by clk)
      Endpoint: core/CPU_Xreg_value_a4_reg[16][31]
                   (rising edge-triggered flip-flop clocked by clk)
      Last common pin: pll/CLK
      Path Group: clk
      Path Type: max
    
      Point                                                          Fanout    Cap      Trans       Incr       Path
      ----------------------------------------------------------------------------------------------------------------
      clock clk (rise edge)                                                                       0.0000     0.0000
      clock network delay (propagated)                                                            0.6993     0.6993
      core/CPU_is_addi_a3_reg/CLK (sky130_fd_sc_hd__dfxtp_1)                           0.7074     0.0000     0.6993 r
      core/CPU_is_addi_a3_reg/Q (sky130_fd_sc_hd__dfxtp_1)                             0.0794     0.4833 &   1.1826 f
      core/CPU_is_addi_a3 (net)                                         4   0.0145 
      core/U474/B (sky130_fd_sc_hd__nor2_2)                                            0.0796     0.0033 &   1.1859 f
      core/U474/Y (sky130_fd_sc_hd__nor2_2)                                            0.1010     0.1110 &   1.2969 r
      core/n144 (net)                                                   2   0.0066 
      core/U476/A (sky130_fd_sc_hd__nand2_1)                                           0.1010     0.0010 &   1.2979 r
      core/U476/Y (sky130_fd_sc_hd__nand2_1)                                           0.0591     0.0778 &   1.3756 f
      core/n147 (net)                                                   2   0.0059 
      core/HFSINV_971_202/A (sky130_fd_sc_hd__inv_1)                                   0.0591     0.0009 &   1.3766 f
      core/HFSINV_971_202/Y (sky130_fd_sc_hd__inv_1)                                   0.0417     0.0592 &   1.4357 r
      core/HFSNET_185 (net)                                             1   0.0036 
      core/ZBUF_544_inst_9215/A (sky130_fd_sc_hd__clkbuf_1)                            0.0417     0.0006 &   1.4364 r
      core/ZBUF_544_inst_9215/X (sky130_fd_sc_hd__clkbuf_1)                            0.1960     0.1812 &   1.6176 r
      core/ZBUF_544_135 (net)                                           2   0.0157 
      core/gre_mt_inst_11510/A (sky130_fd_sc_hd__buf_4)                                0.1967     0.0027 &   1.6202 r
      core/gre_mt_inst_11510/X (sky130_fd_sc_hd__buf_4)                                0.0549     0.1624 &   1.7826 r
      core/gre_net_324 (net)                                            4   0.0131 
      core/gre_mt_inst_12107/A (sky130_fd_sc_hd__clkbuf_1)                             0.0552     0.0025 &   1.7851 r
      core/gre_mt_inst_12107/X (sky130_fd_sc_hd__clkbuf_1)                             0.1819     0.1755 &   1.9605 r
      core/gre_net_921 (net)                                            4   0.0144 
      core/gre_mt_inst_11509/A (sky130_fd_sc_hd__buf_2)                                0.1824     0.0026 &   1.9632 r
      core/gre_mt_inst_11509/X (sky130_fd_sc_hd__buf_2)                                0.0405     0.1451 &   2.1083 r
      core/gre_net_323 (net)                                            1   0.0054 
      core/ropt_mt_inst_12292/A (sky130_fd_sc_hd__buf_6)                               0.0406     0.0011 &   2.1095 r
      core/ropt_mt_inst_12292/X (sky130_fd_sc_hd__buf_6)                               0.0574     0.1019 &   2.2113 r
      core/ropt_net_1067 (net)                                          3   0.0206 
      core/ctmTdsLR_2_898/A (sky130_fd_sc_hd__xnor2_2)                                 0.0580     0.0051 &   2.2165 r
      core/ctmTdsLR_2_898/Y (sky130_fd_sc_hd__xnor2_2)                                 0.0883     0.0845 &   2.3009 f
      core/n210 (net)                                                   2   0.0100 
      core/ctmTdsLR_1_954/A2 (sky130_fd_sc_hd__a21boi_2)                               0.0886     0.0024 &   2.3034 f
      core/ctmTdsLR_1_954/Y (sky130_fd_sc_hd__a21boi_2)                                0.1420     0.1858 &   2.4892 r
      core/n809 (net)                                                   2   0.0088 
      core/U571/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.1420     0.0014 &   2.4905 r
      core/U571/Y (sky130_fd_sc_hd__o21ai_1)                                           0.1041     0.1173 &   2.6078 f
      core/n791 (net)                                                   2   0.0102 
      core/ctmTdsLR_1_960/A1 (sky130_fd_sc_hd__a21boi_2)                               0.1043     0.0025 &   2.6103 f
      core/ctmTdsLR_1_960/Y (sky130_fd_sc_hd__a21boi_2)                                0.1583     0.1894 &   2.7996 r
      core/n774 (net)                                                   2   0.0100 
      core/U576/A2 (sky130_fd_sc_hd__o21ai_2)                                          0.1585     0.0023 &   2.8020 r
      core/U576/Y (sky130_fd_sc_hd__o21ai_2)                                           0.0685     0.0883 &   2.8903 f
      core/n755 (net)                                                   2   0.0097 
      core/ctmTdsLR_1_970/A1 (sky130_fd_sc_hd__a21boi_2)                               0.0687     0.0024 &   2.8927 f
      core/ctmTdsLR_1_970/Y (sky130_fd_sc_hd__a21boi_2)                                0.2003     0.2075 &   3.1001 r
      core/n740 (net)                                                   2   0.0139 
      core/U583/A2 (sky130_fd_sc_hd__o21ai_2)                                          0.2007     0.0033 &   3.1035 r
      core/U583/Y (sky130_fd_sc_hd__o21ai_2)                                           0.0664     0.0953 &   3.1988 f
      core/n722 (net)                                                   1   0.0097 
      core/gre_mt_inst_11983/A (sky130_fd_sc_hd__clkbuf_2)                             0.0665     0.0020 &   3.2008 f
      core/gre_mt_inst_11983/X (sky130_fd_sc_hd__clkbuf_2)                             0.0753     0.1490 &   3.3499 f
      core/gre_net_797 (net)                                            1   0.0168 
      core/ropt_mt_inst_12296/A (sky130_fd_sc_hd__buf_6)                               0.0756     0.0038 &   3.3537 f
      core/ropt_mt_inst_12296/X (sky130_fd_sc_hd__buf_6)                               0.0286     0.1297 &   3.4834 f
      core/ropt_net_1071 (net)                                          2   0.0111 
      core/ctmTdsLR_1_975/A1 (sky130_fd_sc_hd__a21boi_2)                               0.0288     0.0018 &   3.4851 f
      core/ctmTdsLR_1_975/Y (sky130_fd_sc_hd__a21boi_2)                                0.1735     0.1709 &   3.6560 r
      core/n707 (net)                                                   2   0.0114 
      core/U589/A2 (sky130_fd_sc_hd__o21ai_2)                                          0.1737     0.0028 &   3.6589 r
      core/U589/Y (sky130_fd_sc_hd__o21ai_2)                                           0.0768     0.1011 &   3.7600 f
      core/n689 (net)                                                   2   0.0133 
      core/ctmTdsLR_1_976/A1 (sky130_fd_sc_hd__a21boi_2)                               0.0771     0.0034 &   3.7634 f
      core/ctmTdsLR_1_976/Y (sky130_fd_sc_hd__a21boi_2)                                0.1598     0.1797 &   3.9430 r
      core/n674 (net)                                                   2   0.0101 
      core/U213/A2 (sky130_fd_sc_hd__o21ai_2)                                          0.1600     0.0025 &   3.9455 r
      core/U213/Y (sky130_fd_sc_hd__o21ai_2)                                           0.0732     0.0895 &   4.0351 f
      core/n656 (net)                                                   2   0.0100 
      core/ctmTdsLR_1_977/A1 (sky130_fd_sc_hd__a21boi_2)                               0.0734     0.0025 &   4.0376 f
      core/ctmTdsLR_1_977/Y (sky130_fd_sc_hd__a21boi_2)                                0.1761     0.1907 &   4.2283 r
      core/n641 (net)                                                   2   0.0117 
      core/U210/A2 (sky130_fd_sc_hd__o21ai_2)                                          0.1764     0.0029 &   4.2311 r
      core/U210/Y (sky130_fd_sc_hd__o21ai_2)                                           0.0802     0.1008 &   4.3319 f
      core/n623 (net)                                                   2   0.0131 
      core/ctmTdsLR_1_978/A1 (sky130_fd_sc_hd__a21boi_2)                               0.0804     0.0031 &   4.3351 f
      core/ctmTdsLR_1_978/Y (sky130_fd_sc_hd__a21boi_2)                                0.1724     0.1905 &   4.5256 r
      core/n608 (net)                                                   2   0.0113 
      core/U209/A2 (sky130_fd_sc_hd__o21ai_2)                                          0.1726     0.0028 &   4.5284 r
      core/U209/Y (sky130_fd_sc_hd__o21ai_2)                                           0.0753     0.0993 &   4.6277 f
      core/n590 (net)                                                   2   0.0128 
      core/ctmTdsLR_1_979/A1 (sky130_fd_sc_hd__a21boi_2)                               0.0758     0.0030 &   4.6307 f
      core/ctmTdsLR_1_979/Y (sky130_fd_sc_hd__a21boi_2)                                0.1600     0.1793 &   4.8100 r
      core/n575 (net)                                                   2   0.0102 
      core/U215/A2 (sky130_fd_sc_hd__o21ai_2)                                          0.1601     0.0024 &   4.8124 r
      core/U215/Y (sky130_fd_sc_hd__o21ai_2)                                           0.0730     0.0948 &   4.9072 f
      core/n557 (net)                                                   2   0.0117 
      core/ctmTdsLR_1_980/A (sky130_fd_sc_hd__nand2_1)                                 0.0732     0.0024 &   4.9096 f
      core/ctmTdsLR_1_980/Y (sky130_fd_sc_hd__nand2_1)                                 0.0468     0.0649 &   4.9745 r
      core/tmp_net35 (net)                                              1   0.0028 
      core/ctmTdsLR_2_981/A (sky130_fd_sc_hd__nand2_1)                                 0.0468     0.0005 &   4.9751 r
      core/ctmTdsLR_2_981/Y (sky130_fd_sc_hd__nand2_1)                                 0.0527     0.0599 &   5.0350 f
      core/n541 (net)                                                   1   0.0058 
      core/U942/CIN (sky130_fd_sc_hd__fa_2)                                            0.0527     0.0012 &   5.0362 f
      core/U942/COUT (sky130_fd_sc_hd__fa_2)                                           0.0780     0.3440 &   5.3802 f
      core/n527 (net)                                                   2   0.0073 
      core/ctmTdsLR_1_982/A (sky130_fd_sc_hd__nand2_1)                                 0.0783     0.0039 &   5.3840 f
      core/ctmTdsLR_1_982/Y (sky130_fd_sc_hd__nand2_1)                                 0.0512     0.0685 &   5.4526 r
      core/tmp_net36 (net)                                              1   0.0030 
      core/ctmTdsLR_2_983/A (sky130_fd_sc_hd__nand2_1)                                 0.0513     0.0006 &   5.4532 r
      core/ctmTdsLR_2_983/Y (sky130_fd_sc_hd__nand2_1)                                 0.0454     0.0551 &   5.5083 f
      core/n511 (net)                                                   1   0.0045 
      core/U905/CI (sky130_fd_sc_hd__fah_1)                                            0.0454     0.0008 &   5.5090 f
      core/U905/COUT (sky130_fd_sc_hd__fah_1)                                          0.0741     0.2595 &   5.7686 f
      core/n497 (net)                                                   1   0.0063 
      core/U887/CIN (sky130_fd_sc_hd__fa_1)                                            0.0742     0.0012 &   5.7698 f
      core/U887/COUT (sky130_fd_sc_hd__fa_1)                                           0.0852     0.3855 &   6.1553 f
      core/n965 (net)                                                   1   0.0055 
      core/U1370/CI (sky130_fd_sc_hd__fah_1)                                           0.0852     0.0009 &   6.1562 f
      core/U1370/COUT (sky130_fd_sc_hd__fah_1)                                         0.0743     0.2776 &   6.4338 f
      core/n483 (net)                                                   1   0.0064 
      core/U36/CIN (sky130_fd_sc_hd__fa_1)                                             0.0743     0.0012 &   6.4350 f
      core/U36/COUT (sky130_fd_sc_hd__fa_1)                                            0.1152     0.4221 &   6.8571 f
      core/n469 (net)                                                   2   0.0106 
      core/U87/A (sky130_fd_sc_hd__clkinv_1)                                           0.1154     0.0026 &   6.8597 f
      core/U87/Y (sky130_fd_sc_hd__clkinv_1)                                           0.0462     0.0735 &   6.9333 r
      core/n257 (net)                                                   1   0.0041 
      core/U613/A2 (sky130_fd_sc_hd__o21ai_1)                                          0.0462     0.0008 &   6.9340 r
      core/U613/Y (sky130_fd_sc_hd__o21ai_1)                                           0.0611     0.0622 &   6.9963 f
      core/n452 (net)                                                   1   0.0047 
      core/U352/CI (sky130_fd_sc_hd__fah_1)                                            0.0611     0.0008 &   6.9971 f
      core/U352/COUT (sky130_fd_sc_hd__fah_1)                                          0.0785     0.2736 &   7.2707 f
      core/n438 (net)                                                   1   0.0074 
      core/U348/CI (sky130_fd_sc_hd__fah_1)                                            0.0785     0.0012 &   7.2718 f
      core/U348/COUT (sky130_fd_sc_hd__fah_1)                                          0.0687     0.2651 &   7.5369 f
      core/n407 (net)                                                   1   0.0049 
      core/U35/CIN (sky130_fd_sc_hd__fa_1)                                             0.0687     0.0010 &   7.5379 f
      core/U35/COUT (sky130_fd_sc_hd__fa_1)                                            0.0790     0.3743 &   7.9123 f
      core/n382 (net)                                                   1   0.0043 
      core/U33/CI (sky130_fd_sc_hd__fah_1)                                             0.0790     0.0007 &   7.9130 f
      core/U33/COUT (sky130_fd_sc_hd__fah_1)                                           0.0919     0.2963 &   8.2093 f
      core/n357 (net)                                                   2   0.0101 
      core/ctmTdsLR_1_987/A (sky130_fd_sc_hd__nand2_1)                                 0.0920     0.0021 &   8.2115 f
      core/ctmTdsLR_1_987/Y (sky130_fd_sc_hd__nand2_1)                                 0.0489     0.0742 &   8.2857 r
      core/tmp_net38 (net)                                              1   0.0030 
      core/ctmTdsLR_2_988/A (sky130_fd_sc_hd__nand2_1)                                 0.0489     0.0006 &   8.2862 r
      core/ctmTdsLR_2_988/Y (sky130_fd_sc_hd__nand2_1)                                 0.0520     0.0601 &   8.3464 f
      core/n330 (net)                                                   1   0.0057 
      core/U347/CIN (sky130_fd_sc_hd__fa_1)                                            0.0521     0.0011 &   8.3475 f
      core/U347/COUT (sky130_fd_sc_hd__fa_1)                                           0.0888     0.3831 &   8.7306 f
      core/n305 (net)                                                   1   0.0062 
      core/U351/CIN (sky130_fd_sc_hd__fa_1)                                            0.0888     0.0012 &   8.7318 f
      core/U351/COUT (sky130_fd_sc_hd__fa_1)                                           0.0825     0.3869 &   9.1187 f
      core/n262 (net)                                                   1   0.0050 
      core/U617/B (sky130_fd_sc_hd__xor2_1)                                            0.0825     0.0010 &   9.1198 f
      core/U617/X (sky130_fd_sc_hd__xor2_1)                                            0.2335     0.2261 &   9.3459 r
      core/n286 (net)                                                   2   0.0093 
      core/U618/A (sky130_fd_sc_hd__nand2_1)                                           0.2335     0.0014 &   9.3472 r
      core/U618/Y (sky130_fd_sc_hd__nand2_1)                                           0.0773     0.0965 &   9.4437 f
      core/n284 (net)                                                   1   0.0047 
      core/ropt_mt_inst_12416/A (sky130_fd_sc_hd__buf_6)                               0.0773     0.0010 &   9.4447 f
      core/ropt_mt_inst_12416/X (sky130_fd_sc_hd__buf_6)                               0.0334     0.1340 &   9.5787 f
      core/ropt_net_1191 (net)                                          3   0.0149 
      core/ZBUF_1058_inst_9364/A (sky130_fd_sc_hd__clkbuf_1)                           0.0337     0.0032 &   9.5820 f
      core/ZBUF_1058_inst_9364/X (sky130_fd_sc_hd__clkbuf_1)                           0.0695     0.1154 &   9.6974 f
      core/ZBUF_1058_162 (net)                                          1   0.0102 
      core/ropt_mt_inst_12557/A (sky130_fd_sc_hd__buf_6)                               0.0696     0.0028 &   9.7002 f
      core/ropt_mt_inst_12557/X (sky130_fd_sc_hd__buf_6)                               0.0328     0.1301 &   9.8303 f
      core/ropt_net_1332 (net)                                          3   0.0145 
      core/gre_mt_inst_11847/A (sky130_fd_sc_hd__buf_2)                                0.0331     0.0031 &   9.8333 f
      core/gre_mt_inst_11847/X (sky130_fd_sc_hd__buf_2)                                0.0346     0.1223 &   9.9556 f
      core/gre_net_661 (net)                                            2   0.0078 
      core/ropt_mt_inst_12471/A (sky130_fd_sc_hd__buf_6)                               0.0347     0.0012 &   9.9569 f
      core/ropt_mt_inst_12471/X (sky130_fd_sc_hd__buf_6)                               0.0508     0.1304 &  10.0873 f
      core/ropt_net_1246 (net)                                          7   0.0356 
      core/ropt_mt_inst_12564/A (sky130_fd_sc_hd__buf_6)                               0.0519     0.0068 &  10.0941 f
      core/ropt_mt_inst_12564/X (sky130_fd_sc_hd__buf_6)                               0.0366     0.1240 &  10.2182 f
      core/ropt_net_1339 (net)                                          3   0.0169 
      core/U635/B2 (sky130_fd_sc_hd__o22ai_1)                                          0.0370     0.0034 &  10.2216 f
      core/U635/Y (sky130_fd_sc_hd__o22ai_1)                                           0.2200     0.1693 &  10.3908 r
      core/n2945 (net)                                                  1   0.0077 
      core/CPU_Xreg_value_a4_reg[16][31]/D (sky130_fd_sc_hd__dfxtp_4)                  0.2200     0.0011 &  10.3919 r
      data arrival time                                                                                     10.3919
    
      clock clk (rise edge)                                                                      10.0000    10.0000
      clock network delay (propagated)                                                            1.0534    11.0534
      clock reconvergence pessimism                                                               0.0000    11.0534
      clock uncertainty                                                                          -0.5000    10.5534
      core/CPU_Xreg_value_a4_reg[16][31]/CLK (sky130_fd_sc_hd__dfxtp_4)                                     10.5534 r
      library setup time                                                                         -0.0632    10.4901
      data required time                                                                                    10.4901
      ----------------------------------------------------------------------------------------------------------------
      data required time                                                                                    10.4901
      data arrival time                                                                                    -10.3919
      ----------------------------------------------------------------------------------------------------------------
      slack (MET)                                                                                            0.0983
    

    
    1
    
    ****************************************
    Report : timing
    	-path_type full
    	-delay_type min
    	-input_pins
    	-nets
    	-max_paths 1
    	-transition_time
    	-capacitance
    	-sort_by slack
    Design : vsdbabysoc
    Version: T-2022.03-SP5-4
    Date   : Fri Jul 19 13:58:39 2024
    ****************************************
    
    
      Startpoint: core/CPU_Xreg_value_a4_reg[18][26]
                   (rising edge-triggered flip-flop clocked by clk)
      Endpoint: core/CPU_Xreg_value_a4_reg[18][26]
                   (rising edge-triggered flip-flop clocked by clk)
      Last common pin: pll/CLK
      Path Group: clk
      Path Type: min
    
      Point                                                            Fanout    Cap      Trans       Incr       Path
      ------------------------------------------------------------------------------------------------------------------
      clock clk (rise edge)                                                                         0.0000     0.0000
      clock network delay (propagated)                                                              0.9976     0.9976
      core/CPU_Xreg_value_a4_reg[18][26]/CLK (sky130_fd_sc_hd__dfxtp_4)                  0.2158     0.0000     0.9976 r
      core/CPU_Xreg_value_a4_reg[18][26]/Q (sky130_fd_sc_hd__dfxtp_4)                    0.0332     0.3871 &   1.3847 f
      core/CPU_Xreg_value_a4[18][26] (net)                                2   0.0056 
      core/U26/A (sky130_fd_sc_hd__clkinv_1)                                             0.0333     0.0006 &   1.3854 f
      core/U26/Y (sky130_fd_sc_hd__clkinv_1)                                             0.0260     0.0381 &   1.4234 r
      core/n410 (net)                                                     1   0.0032 
      core/U804/A2 (sky130_fd_sc_hd__o22ai_1)                                            0.0260     0.0006 &   1.4240 r
      core/U804/Y (sky130_fd_sc_hd__o22ai_1)                                             0.0467     0.0636 &   1.4876 f
      core/n3003 (net)                                                    1   0.0034 
      core/CPU_Xreg_value_a4_reg[18][26]/D (sky130_fd_sc_hd__dfxtp_4)                    0.0467     0.0005 &   1.4882 f
      data arrival time                                                                                        1.4882
    
      clock clk (rise edge)                                                                         0.0000     0.0000
      clock network delay (propagated)                                                              0.9976     0.9976
      clock reconvergence pessimism                                                                 0.0000     0.9976
      clock uncertainty                                                                             0.5000     1.4976
      core/CPU_Xreg_value_a4_reg[18][26]/CLK (sky130_fd_sc_hd__dfxtp_4)                                        1.4976 r
      library hold time                                                                            -0.0099     1.4877
      data required time                                                                                       1.4877
      ------------------------------------------------------------------------------------------------------------------
      data required time                                                                                       1.4877
      data arrival time                                                                                       -1.4882
      ------------------------------------------------------------------------------------------------------------------
      slack (MET)                                                                                              0.0005
    
    
    1




Script to run Prime Time STA analysis for all available PVT Corners :


    set m1 ""
    set pvt ""
    set wns ""
    set whs ""
    set FH [open report_timing_prime_time.rpt w]
    puts $FH "PVT_Corner\tWNS\tWHS"
    
    
    set lib_files [glob -directory /home/subhasis/VSDBabySoC/src/timing_libs/ -type f *.db]
    
    foreach lib_file_paths $lib_files {
    	
    
    regexp {.*\/sky130_fd_sc_hd__(.*)\.db$} $lib_file_paths m1 pvt
    
    set link_path "* /home/subhasis/VSDBabySoC/src/lib/avsdpll.db /home/subhasis/VSDBabySoC/src/lib/avsddac.db"
    lappend link_path $lib_file_paths
    
    read_verilog /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route_net_max_cap.v
    current_design vsdbabysoc
    
    link_design
    read_sdc /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route.sdc
    read_parasitics /home/subhasis/VSDBabySoC/output/vsdbabysoc_parasitics_max_cap.temp1_25.spef
    
    set wns [get_attribute [get_timing_paths -delay_type max -max_paths 1] slack]
    set whs [get_attribute [get_timing_paths -delay_type min -max_paths 1] slack]
    
    puts $FH "$pvt\t$wns\t$whs"
    
    remove_annotated_parasitics -all
    reset_design
    remove_design -all
    remove_lib -all
    
    }
    
    
    close $FH

**Table for Worst Negative/Setup Slack (WNS) & Worst Hold Slack (WHS) for different available PVT corners from Prime Time Analysis, for our BabySoC Design :**

| PVT_Corner   | WNS         | WHS        |
| ------------ | ----------- | ---------- |
| ff_100C_1v65 | 2.024472    | \-0.107654 |
| ff_100C_1v95 | 3.62175     | \-0.191663 |
| ff_n40C_1v56 | 0.152961    | \-0.110734 |
| ff_n40C_1v65 | 1.342054    | \-0.127069 |
| ff_n40C_1v76 | 2.402224    | \-0.152157 |
| ff_n40C_1v95 | 3.641013    | \-0.192163 |
| ss_100C_1v40 | \-17.748085 | 0.897667   |
| ss_100C_1v60 | \-9.124487  | 0.496103   |
| ss_n40C_1v28 | \-60.347878 | 1.530735   |
| ss_n40C_1v35 | \-39.038769 | 1.033306   |
| ss_n40C_1v40 | \-29.767887 | 0.824017   |
| ss_n40C_1v44 | \-24.336306 | 0.741806   |
| ss_n40C_1v60 | \-11.865104 | 0.371712   |
| ss_n40C_1v76 | \-5.939972  | 0.149654   |
| tt_025C_1v80 | 0.098257    | 0.000461   |
| tt_100C_1v80 | 0.203251    | 0.006439   |

![image](https://github.com/user-attachments/assets/1e257266-7cc0-4813-afee-808098ca1ec4)

![image](https://github.com/user-attachments/assets/ab7d0b65-7d79-471b-b723-5de6567a8513)


This huge variation in our results from Post-Synthesis STA is because of following reasons :

1) Real Wires (post-routing) vs no wires (post-synth)
2) Real,Propagated Clock Tree (post-routing) vs Ideal Clock Network (post-synth).
3) Prime Time TIming Analysis Tool  vs DC Internal Timing Analysis Tool.


</details>

<details>

<summary>Day 18 - ECO using Prime Time</summary>


Engineering Change Orders (ECOs) play a crucial role in the VLSI (Very Large Scale Integration) design process, particularly in accommodating changes and rectifying errors in semiconductor chip designs. This process is essential for enhancing design efficiency and minimizing costs associated with production.

## Definition and Purpose of ECO

An Engineering Change Order (ECO) is a method used to implement changes in the design of a semiconductor chip after it has undergone various stages such as synthesis, placement, and routing. The primary purpose of an ECO is to allow for modifications that can address functional errors, optimize performance, or meet new specifications without restarting the entire design cycle. This is particularly important in the competitive semiconductor industry, where time-to-market is critical.

## Types of ECO

ECOs can be classified into two main categories based on their implementation scope:

1. **All Layers ECO**: This type involves changes that require modifications across all layers of the chip, including both base and metal layers. It is typically used when significant changes are needed, such as updates to hard macro cells or extensive modifications that cannot be confined to a few layers.

2. **Metal-Only ECO**: This approach focuses on making changes only to the metal layers, minimizing the need to alter the base layers. This is often preferred to reduce costs associated with mask production, as the base layers are generally more expensive to modify.

## ECO Process

The ECO process typically involves several key steps:

1. **Specification of Changes**: The first step is to define the changes needed in the design.
   
2. **Netlist Comparison**: The modified netlist is compared against the original "golden" netlist to identify differences.

3. **Placement and Routing Updates**: The design undergoes placement adjustments for the new logic and routing optimizations to accommodate these changes.

4. **Verification**: Formal verification is conducted to ensure that the changes meet the design specifications and do not introduce new errors.

## Challenges in ECO Implementation

Despite the advantages of ECOs, challenges remain, particularly in terms of computational complexity and the physical constraints of the design. The need for automation in the ECO process is increasingly recognized, as manual implementations can be time-consuming and prone to errors. Current research focuses on developing more efficient ECO tools that can handle the intricate requirements of modern VLSI designs.

## Conclusion

In summary, Engineering Change Orders are a vital component of the VLSI design flow, enabling designers to efficiently implement necessary modifications while preserving previously invested efforts. As the complexity of designs increases, the need for effective ECO processes will continue to grow, highlighting the importance of ongoing research and development in this area.

Citations:
[1] https://www.synopsys.com/glossary/what-is-functional-eco.html
[2] https://www.linkedin.com/pulse/engineering-change-order-physical-design
[3] https://vlsiuniverse.blogspot.com/2013/05/engineering-change-order-eco.html
[4] https://www.techsimplifiedtv.in/2023/11/what-is-engineering-change-ordereco-in.html
[5] https://people.eecs.berkeley.edu/~alanmi/publications/other/date20_eco1.pdf
[6] https://www.youtube.com/watch?v=n63oF94F6JA




#### Lab - Timing ECO using Prime Time for our VSDBabySoC Design :

Script to setup Prime Time for ECO run :


    set link_path "* /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__tt_025C_1v80.db /home/subhasis/VSDBabySoC/src/lib/avsdpll.db /home/subhasis/VSDBabySoC/src/lib/avsddac.db"
    
    read_verilog /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route_net_max_cap.v
    current_design vsdbabysoc
    link_design
    set_min_library -min_version /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__ff_n40C_1v95.db /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__tt_025C_1v80.db
    
    read_sdc /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route.sdc
    #read_parasitics /home/subhasis/VSDBabySoC/output/vsdbabysoc_parasitics.temp1_25.spef
    read_parasitics /home/subhasis/VSDBabySoC/output/vsdbabysoc_parasitics_max_cap.temp1_25.spef
    
    update_timing -full
    
    report_analysis_coverage > /home/subhasis/VSDBabySoC/output/reports/prime_time_analysis_coverage.rpt
    report_constraint -all_violators > /home/subhasis/VSDBabySoC/output/reports/prime_time_constraint.rpt
    report_timing -delay_type max -capacitance -input_pins -nets -transition_time -nosplit -significant_digits 4 > /home/subhasis/VSDBabySoC/output/reports/prime_time_setup_timing.rpt
    report_timing -delay_type min -capacitance -input_pins -nets -transition_time -nosplit -significant_digits 4 > /home/subhasis/VSDBabySoC/output/reports/prime_time_hold_timing.rpt

    
    ****************************************
    Report : analysis_coverage
    Design : vsdbabysoc
    Version: T-2022.03-SP5-4
    Date   : Tue Jul 23 15:14:10 2024
    ****************************************
    
    Type of Check         Total              Met         Violated         Untested
    --------------------------------------------------------------------------------
    setup                   676       658 ( 97%)        17 (  3%)         1 (  0%)
    hold                    676        35 (  5%)       640 ( 95%)         1 (  0%)
    min_pulse_width        1352      1352 (100%)         0 (  0%)         0 (  0%)
    --------------------------------------------------------------------------------
    All Checks             2704      2045 ( 76%)       657 ( 24%)         2 (  0%)
    
    1
    

The `fix_eco_timing`command fixes or improves timing violations by  sizing  cells  and inserting buffers or inverter pairs. 
It attempts to fix the specified types of violations while minimizing the impact on  area and power.

After the violations are fixed, we can write out the design changes as a script by using the write_changes command. we can use the script to implement the same changes in another PrimeTime session or another 
tool (Design Compiler, IC Compiler, or IC Compiler II).  A  list  of  design changes  created  in  this  flow  is called an engineering change order (ECO).

The `fix_eco_timing` command has options to specify the following  fixing
parameters:

* The type of timing violations to fix (setup or hold)
* The  scope of the design to be fixed (from/to startpoints/endpoints,
 path groups, a path collection, or the whole design)
* The fixing methods (cell sizing, buffer insertion, or  inverter  pair
 insertion)
* The  list  of  library cells that can be used for buffer or inverter
 pair insertion
* The types of cells to be modified (data paths, sequential  cells,  or
 clock networks)
* The targeted amount of timing margin (slack) to achieve
* The graph-based analysis mode (graph-based, path-based, or path-based
 exhaustive)
* The physical placement and sizing mode  (none,  open  site,  occupied
 site, or freeze silicon)

We must specify the fixing type, either setup or hold, using the -type option because of the different nature of these violations. By default, setup fixing uses cell sizing alone to reduce data path delays, 
whereas hold fixing uses both cell sizing and buffer insertion to increase data path delays. By default, fixing occurs only in data paths, not in clock networks.

The command performs fixing using multiple  iterations,  starting  with the worst violations. It repeats fixing iterations until all violations are fixed or it determines that further fixing is not worth the 
runtime cost,  based  on  the current quality of results and fixing option set-
tings.  We can generate a report on unfixable violations by using  the -verbose  or  -estimate_unfixable_reasons  option. Based on the report, we can target the unfixed violations using another fix_eco_timing 
command with different option settings.

Setup fixing seeks to avoid introducing design rule checking (DRC) violations, but it is allowed to introduce hold violations  because  setup violations  are  harder to fix.  Hold fixing seeks to avoid 
introducing both setup and DRC violations. To fix both setup and  hold  violations, fix  setup  violations  first,  then  hold  violations,  using separate `fix_eco_timing` commands.


* `fix_eco_timing -type setup`- to fix setup violations.

        Final ECO Summary:
        --------------------------------------------------------
        Number of size_cell commands                           6
        Total number of commands                               6
        Area increased by cell sizing                      40.04
        Total area increased                               40.04
        
        Fixing Summary:
        --------------------------------------------------------
        Total violating endpoints found                       17
        Total violating endpoints fixed                       17
        Total violating endpoints remaining                    0
        Total percentage of violations fixed               100.0%

* `fix_eco_timing -type hold -methods insert_buffer -buffer_list {sky130_fd_sc_hd__buf_1 sky130_fd_sc_hd__buf_2 sky130_fd_sc_hd__buf_4 sky130_fd_sc_hd__buf_8}` - to fix hold violations by inserting buffers.
        
        Inserted buffers:
           Count Lib_cell               Area          Total_area
        --------------------------------------------------------
              69 sky130_fd_sc_hd__buf_2   5.00              345.33
             533 sky130_fd_sc_hd__buf_1   3.75             2000.67
             570 sky130_fd_sc_hd__buf_4   7.51             4279.10
             618 sky130_fd_sc_hd__buf_8  15.01             9278.90
        --------------------------------------------------------
            1790 TOTAL                                  15904.00
        
        Final ECO Summary:
        --------------------------------------------------------
        Number of insert_buffer commands                    1790
        Total number of commands                            1790
        Area increased by buffer insertion              15903.94
        Total area increased                            15903.94
        
        Fixing Summary:
        --------------------------------------------------------
        Total violating endpoints found                      640
        Total violating endpoints fixed                      640
        Total violating endpoints remaining                    0
        Total percentage of violations fixed               100.0%

* After ECO fixing :
        
        ****************************************
        Report : analysis_coverage
        Design : vsdbabysoc
        Version: T-2022.03-SP5-4
        Date   : Tue Jul 23 15:44:26 2024
        ****************************************
        
        Type of Check         Total              Met         Violated         Untested
        --------------------------------------------------------------------------------
        setup                   676       675 (100%)         0 (  0%)         1 (  0%)
        hold                    676       675 (100%)         0 (  0%)         1 (  0%)
        min_pulse_width        1352      1352 (100%)         0 (  0%)         0 (  0%)
        --------------------------------------------------------------------------------
        All Checks             2704      2702 (100%)         0 (  0%)         2 (  0%)


* `write_changes -format icc2tcl -output output/vsdbabysoc_eco.tcl` - The write_changes command writes out the netlist changes that were made to the current design after the design was linked.
                                                                      The output is  typically  formatted  as  a  script that can be run in PrimeTime or another tool such as IC Compiler II or a third-party place
                                                                      and-route tool.



Screenshot of netlist changes obtained after `fix_eco_timing` and `write_changes` command execution :



![image](https://github.com/user-attachments/assets/9af32091-aca0-441f-88b3-f173785c02e8)



* The above `vsdbabysoc_eco.tcl` file can be sourced in the PNR/Implementation Tool in our Post-Route database and further incremental place and route can be performed for this newly inserted & sized cells.



* `check_legality` failing after sourcing `vsdbabysoc_eco.tcl` in ICC2 Compiler to perform ECO and fix Timing Violations :
  
![image](https://github.com/user-attachments/assets/4255d9ca-e808-4a44-802e-b07f6ead713d)

* use `legalize_placement` command to resolve placement legalization issues.

![image](https://github.com/user-attachments/assets/9b776ed2-b311-48a8-b36f-5ca3f14d5d2b)


* `route_eco` -The  route_eco command performs ECO routing. It first connects the open nets and then fixes the DRC violations. The options control which  nets are  connected  and  in  which areas of the chip 
               the DRC violations are fixed. Use this command only after signal routing has been completed.

  ![image](https://github.com/user-attachments/assets/f88fd1ba-acec-400f-8c8a-b843ef68cd1f)

* We have to again extract `.SPEF` file and post_route netlist and perform Prime Time STA,to check if our timing violations have been fixed by the ECO or not.

* Script to setup Prime Time STA for post-ECO database :

        set link_path "* /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__tt_025C_1v80.db /home/subhasis/VSDBabySoC/src/lib/avsdpll.db /home/subhasis/VSDBabySoC/src/lib/avsddac.db"
        
        read_verilog /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route_net_max_cap_post_eco.v
        current_design vsdbabysoc
        link_design
        set_min_library -min_version /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__ff_n40C_1v95.db /home/subhasis/VSDBabySoC/src/timing_libs/sky130_fd_sc_hd__tt_025C_1v80.db
        
        read_sdc /home/subhasis/VSDBabySoC/output/vsdbabysoc_post_route.sdc
        #read_parasitics /home/subhasis/VSDBabySoC/output/vsdbabysoc_parasitics.temp1_25.spef
        read_parasitics /home/subhasis/VSDBabySoC/output/vsdbabysoc_parasitics_max_cap_post_eco.temp1_25.spef
        
        update_timing -full
        
        report_analysis_coverage > /home/subhasis/VSDBabySoC/output/reports/prime_time_analysis_coverage.rpt
        report_constraint -all_violators > /home/subhasis/VSDBabySoC/output/reports/prime_time_constraint.rpt
        report_timing -delay_type max -capacitance -input_pins -nets -transition_time -nosplit -significant_digits 4 > /home/subhasis/VSDBabySoC/output/reports/prime_time_setup_timing.rpt
        report_timing -delay_type min -capacitance -input_pins -nets -transition_time -nosplit -significant_digits 4 > /home/subhasis/VSDBabySoC/output/reports/prime_time_hold_timing.rpt


* report_analysis_coverage report in Prime Time using post_eco database :

        ****************************************
        Report : analysis_coverage
        Design : vsdbabysoc
        Version: T-2022.03-SP5-4
        Date   : Mon Aug  5 15:48:55 2024
        ****************************************
        
        Type of Check         Total              Met         Violated         Untested
        --------------------------------------------------------------------------------
        setup                   676       675 (100%)         0 (  0%)         1 (  0%)
        hold                    676       675 (100%)         0 (  0%)         1 (  0%)
        min_pulse_width        1352      1352 (100%)         0 (  0%)         0 (  0%)
        --------------------------------------------------------------------------------
        All Checks             2704      2702 (100%)         0 (  0%)         2 (  0%)

**Note :**

* ECO flow may have to be run multiple times to resolve all timing violations.



</details>
  






























 





  



































  





























  

  







   








































    


    



























